{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is ElectionGuard? ElectionGuard is an open source software development kit (SDK) that makes voting more secure, transparent and accessible. It is designed for election system vendors to incorporate end-to-end verifiability into their systems and any interested organization to perform and publish post-election audits using ElectionGuard as a secure publishing platform. New to ElectionGuard? Welcome! Thanks for your interest. Trying to figure out how to help and learn? If you're a developer, head over to the developer getting started . If you're an election administrator or want to learn more about ElectionGuard and its underpinnings, start with the guide . If you want to help and aren't a developer, all kinds of help with documentation, outreach, and advocacy is welcomed. Follow discussions , join the office hours , and check out the roadmap to see where it's intended to go. Open-Source This library and all linked ElectionGuard projects, are licensed under the MIT license. There is no fee for using ElectionGuard. Security Issues Reporting We encourage the developer and security community to conduct research, report issues, and suggest improvements on this code base. However, unlike performance or feature bugs, please do not report security vulnerabilities in public Github comments. Each repository has a SECURITY file with instructions on responsibly reporting security vulnerabilities under Microsoft's CVD process. Contributing Help defend democracy and contribute to the project . We welcome discussions on our discussions page , feel free to check in and ask your questions and drop your suggestions regarding the specifications over there. Questions ElectionGuard would love for you to ask questions out in the open using Github Issues. If you really want to email the ElectionGuard team, reach out at electionguard@microsoft.com . Thank you A huge thank you to those who have helped us along the way: Josh Benaloh (whose PhD thesis was the genesis of much of this work) Our contributors and community InfernoRed Technology VotingWorks Center for Civic Design Oxide Design Many teams within Microsoft","title":"What is ElectionGuard?"},{"location":"#_1","text":"","title":""},{"location":"#what-is-electionguard","text":"ElectionGuard is an open source software development kit (SDK) that makes voting more secure, transparent and accessible. It is designed for election system vendors to incorporate end-to-end verifiability into their systems and any interested organization to perform and publish post-election audits using ElectionGuard as a secure publishing platform. New to ElectionGuard? Welcome! Thanks for your interest. Trying to figure out how to help and learn? If you're a developer, head over to the developer getting started . If you're an election administrator or want to learn more about ElectionGuard and its underpinnings, start with the guide . If you want to help and aren't a developer, all kinds of help with documentation, outreach, and advocacy is welcomed. Follow discussions , join the office hours , and check out the roadmap to see where it's intended to go.","title":"What is ElectionGuard?"},{"location":"#open-source","text":"This library and all linked ElectionGuard projects, are licensed under the MIT license. There is no fee for using ElectionGuard.","title":"Open-Source"},{"location":"#security-issues-reporting","text":"We encourage the developer and security community to conduct research, report issues, and suggest improvements on this code base. However, unlike performance or feature bugs, please do not report security vulnerabilities in public Github comments. Each repository has a SECURITY file with instructions on responsibly reporting security vulnerabilities under Microsoft's CVD process.","title":"Security Issues Reporting"},{"location":"#contributing","text":"Help defend democracy and contribute to the project . We welcome discussions on our discussions page , feel free to check in and ask your questions and drop your suggestions regarding the specifications over there.","title":"Contributing"},{"location":"#questions","text":"ElectionGuard would love for you to ask questions out in the open using Github Issues. If you really want to email the ElectionGuard team, reach out at electionguard@microsoft.com .","title":"Questions"},{"location":"#thank-you","text":"A huge thank you to those who have helped us along the way: Josh Benaloh (whose PhD thesis was the genesis of much of this work) Our contributors and community InfernoRed Technology VotingWorks Center for Civic Design Oxide Design Many teams within Microsoft","title":"Thank you"},{"location":"basics/Introduction/","text":"Introduction Work in Progress This is a work in progress. Feel free to contribute.","title":"Introduction"},{"location":"basics/Introduction/#introduction","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Introduction"},{"location":"basics/steps/0_Configure_Election/","text":"Configure Election Manifest An election in ElectionGuard is defined as a set of metadata and cryptographic artifacts necessary to encrypt, conduct, tally, decrypt, and verify an election. The Data format used for election metadata is based on the NIST Election Common Standard Data Specification but includes some modifications to support the end-to-end cryptography of ElectionGuard. Election metadata is described in a specific format parseable into an Election Manifest and its validity is checked to ensure that it is of an appropriate structure to conduct an End-to-End Verified ElectionGuard Election. ElectionGuard only verifies the components of the election metadata that are necessary to encrypt and decrypt the election. Some components of the election metadata are not checked for structural validity, but are used when generating a hash representation of the Election Manifest. Additionally, a context is created during the Key Ceremony that includes the cryptographic artifacts necessary for encrypting ballots. Guardians A core component of the ElectionGuard security architecture involves election guardians. Election guardians are trustworthy, independent individuals that participate in the key and tally ceremonies of ElectionGuard e2e-v elections. By using multiple guardians to conduct the tally process, no one person controls all the keys necessary to decrypt ballots. However, with multiple actors it becomes necessary to compensate for guardians going missing or obstructing the tally process by supporting quorums and dispute resolution when a guardian challenges a result, as they are allowed. As such, it is necessary when setting up an election to specify the maximum number of guardians that can participate, but also the quorum, the minimum number of guardians necessary to perform a tally. The more guardians that are allowed, the higher the quorum can (and should) be set (a high number of guardians with a low quorum creates an opportunity for collusion among guardians). It is advised to set quorums not just above majority levels but as high as can be reasonably expected (e.g. set a quorum of 5 or 6, not 4, for an election with 7 guardians).","title":"Configure Election"},{"location":"basics/steps/0_Configure_Election/#configure-election","text":"","title":"Configure Election"},{"location":"basics/steps/0_Configure_Election/#manifest","text":"An election in ElectionGuard is defined as a set of metadata and cryptographic artifacts necessary to encrypt, conduct, tally, decrypt, and verify an election. The Data format used for election metadata is based on the NIST Election Common Standard Data Specification but includes some modifications to support the end-to-end cryptography of ElectionGuard. Election metadata is described in a specific format parseable into an Election Manifest and its validity is checked to ensure that it is of an appropriate structure to conduct an End-to-End Verified ElectionGuard Election. ElectionGuard only verifies the components of the election metadata that are necessary to encrypt and decrypt the election. Some components of the election metadata are not checked for structural validity, but are used when generating a hash representation of the Election Manifest. Additionally, a context is created during the Key Ceremony that includes the cryptographic artifacts necessary for encrypting ballots.","title":"Manifest"},{"location":"basics/steps/0_Configure_Election/#guardians","text":"A core component of the ElectionGuard security architecture involves election guardians. Election guardians are trustworthy, independent individuals that participate in the key and tally ceremonies of ElectionGuard e2e-v elections. By using multiple guardians to conduct the tally process, no one person controls all the keys necessary to decrypt ballots. However, with multiple actors it becomes necessary to compensate for guardians going missing or obstructing the tally process by supporting quorums and dispute resolution when a guardian challenges a result, as they are allowed. As such, it is necessary when setting up an election to specify the maximum number of guardians that can participate, but also the quorum, the minimum number of guardians necessary to perform a tally. The more guardians that are allowed, the higher the quorum can (and should) be set (a high number of guardians with a low quorum creates an opportunity for collusion among guardians). It is advised to set quorums not just above majority levels but as high as can be reasonably expected (e.g. set a quorum of 5 or 6, not 4, for an election with 7 guardians).","title":"Guardians"},{"location":"basics/steps/1_Key_Ceremony/","text":"Key Ceremony The ElectionGuard Key Ceremony is the process used by Election Officials to share encryption keys for an election. Before an election, a fixed number of Guardians are selected to hold the private keys needed to decrypt the election results. A Quorum count of Guardians can also be specified to compensate for guardians who may be missing at the time of Decryption. For instance, 5 Guardians may be selected to hold the keys, but only 3 of them are required to decrypt the election results. Guardians are typically Election Officials, Trustees Canvass Board Members, Government Officials or other trusted authorities who are responsible and accountable for conducting the election. Summary The Key Ceremony is broken into several high-level steps. Each Guardian must announce their attendance in the key ceremony, generate their own public-private key pairs, and then share those key pairs with the Quorum. Then the data that is shared is mathematically verified using Non-Interactive Zero Knowledge Proofs, and finally a joint public key is created to encrypt ballots in the election. Attendance Guardians exchange all public keys and ensure each fellow guardian has received an election and auxiliary public key ensuring that all guardians are in attendance. Key Sharing Guardians generate a partial key backup for each guardian and share with that designated key with that guardian. Then each designated guardian sends a verification back to the sender. The sender then publishes to the group when all verifications are received. Joint Key The final step is to publish the joint election key after all keys and backups have been shared.","title":"Key Ceremony"},{"location":"basics/steps/1_Key_Ceremony/#key-ceremony","text":"The ElectionGuard Key Ceremony is the process used by Election Officials to share encryption keys for an election. Before an election, a fixed number of Guardians are selected to hold the private keys needed to decrypt the election results. A Quorum count of Guardians can also be specified to compensate for guardians who may be missing at the time of Decryption. For instance, 5 Guardians may be selected to hold the keys, but only 3 of them are required to decrypt the election results. Guardians are typically Election Officials, Trustees Canvass Board Members, Government Officials or other trusted authorities who are responsible and accountable for conducting the election.","title":"Key Ceremony"},{"location":"basics/steps/1_Key_Ceremony/#summary","text":"The Key Ceremony is broken into several high-level steps. Each Guardian must announce their attendance in the key ceremony, generate their own public-private key pairs, and then share those key pairs with the Quorum. Then the data that is shared is mathematically verified using Non-Interactive Zero Knowledge Proofs, and finally a joint public key is created to encrypt ballots in the election.","title":"Summary"},{"location":"basics/steps/1_Key_Ceremony/#attendance","text":"Guardians exchange all public keys and ensure each fellow guardian has received an election and auxiliary public key ensuring that all guardians are in attendance.","title":"Attendance"},{"location":"basics/steps/1_Key_Ceremony/#key-sharing","text":"Guardians generate a partial key backup for each guardian and share with that designated key with that guardian. Then each designated guardian sends a verification back to the sender. The sender then publishes to the group when all verifications are received.","title":"Key Sharing"},{"location":"basics/steps/1_Key_Ceremony/#joint-key","text":"The final step is to publish the joint election key after all keys and backups have been shared.","title":"Joint Key"},{"location":"basics/steps/2_Encryption/","text":"Encryption The primary function of ElectionGuard is to encrypt ballots. Ballots are encrypted on a uniquely identified device within the context of a specific election. The election public key is used to encrypt ballots. A master nonce value is generated for each ballot and the nonce is used to derive other nonce values for encrypting the selection on each ballot.","title":"Encryption"},{"location":"basics/steps/2_Encryption/#encryption","text":"The primary function of ElectionGuard is to encrypt ballots. Ballots are encrypted on a uniquely identified device within the context of a specific election. The election public key is used to encrypt ballots. A master nonce value is generated for each ballot and the nonce is used to derive other nonce values for encrypting the selection on each ballot.","title":"Encryption"},{"location":"basics/steps/3_Cast_and_Challenge/","text":"Cast and Challenge Each ballot that is completed by a voter must be either cast or challenged. A cast ballot is a ballot that the voter accepts as valid and wishes to include in the official election tally. A challenge ballot, also referred to as a spoiled ballot, is a ballot that the voter does not accept as valid and wishes to exclude from the official election tally. ElectionGuard includes a mechanism to mark a specific ballot as either cast or spoiled. Cast ballots are included in the tally record, while spoiled ballots are not. Spoiled ballots are decrypted into plaintext and published along with the rest of the election record.","title":"Cast and Challenge"},{"location":"basics/steps/3_Cast_and_Challenge/#cast-and-challenge","text":"Each ballot that is completed by a voter must be either cast or challenged. A cast ballot is a ballot that the voter accepts as valid and wishes to include in the official election tally. A challenge ballot, also referred to as a spoiled ballot, is a ballot that the voter does not accept as valid and wishes to exclude from the official election tally. ElectionGuard includes a mechanism to mark a specific ballot as either cast or spoiled. Cast ballots are included in the tally record, while spoiled ballots are not. Spoiled ballots are decrypted into plaintext and published along with the rest of the election record.","title":"Cast and Challenge"},{"location":"basics/steps/4_Decryption/","text":"Decryption At the conclusion of voting, all of the cast ballots are published in their encrypted form in the election record together with the proofs that the ballots are well-formed. Additionally, all of the encryptions of each option are homomorphically-combined to form an encryption of the total number of times that each option was selected. The homomorphically-combined encryptions are decrypted to generate the election tally. Individual cast ballots are not decrypted. Individual spoiled ballots are decrypted and the plaintext values are published along with the encrypted representations and the proofs. In order to decrypt the homomorphically-combined encryption of each selection, each Guardian participating in the decryption must compute a specific Decryption Share of the decryption. It is preferable that all guardians be present for decryption, however in the event that guardians cannot be present, Electionguard includes a mechanism to decrypt with the Quorum of Guardians. During the Key Ceremony a Quorum of Guardians is defined that represents the minimum number of guardians that must be present to decrypt the election. If the decryption is to proceed with a Quorum of Guardians greater than or equal to the Quorum count, but less than the total number of guardians, then a subset of the Available Guardians must also each construct a Partial Decryption Share for the missing Missing Guardian, in addition to providing their own Decryption Share. It is important to note that mathematically not every present guardian has to compute a Partial Decryption Share for every Missing Guardian. Only the Quorum Count of guardians are necessary to construct Partial Decryption Shares in order to compensate for any Missing Guardian. In this implementation, ElectionGuard takes an approach that utilizes all Available Guardians to compensate for Missing Guardians. When it is determined that guardians are missing, all available guardians each calculate a Partial Decryption Share for the missing guardian and publish the result. A Quorum of Guardians count of available Partial Decryption Shares is randomly selected from the pool of available partial decryption shares for a givenMissing Guardian. If more than one guardian is missing, we randomly choose to ignore the Partial Decryption Share provided by one of the Available Guardians whose partial decryption share was chosen for the previous Missing Guardian, and randomly select again from the pool of available Partial Decryption Shares. This ensures that all available guardians have the opportunity to participate in compensating for Missing Guardians.","title":"Decryption"},{"location":"basics/steps/4_Decryption/#decryption","text":"At the conclusion of voting, all of the cast ballots are published in their encrypted form in the election record together with the proofs that the ballots are well-formed. Additionally, all of the encryptions of each option are homomorphically-combined to form an encryption of the total number of times that each option was selected. The homomorphically-combined encryptions are decrypted to generate the election tally. Individual cast ballots are not decrypted. Individual spoiled ballots are decrypted and the plaintext values are published along with the encrypted representations and the proofs. In order to decrypt the homomorphically-combined encryption of each selection, each Guardian participating in the decryption must compute a specific Decryption Share of the decryption. It is preferable that all guardians be present for decryption, however in the event that guardians cannot be present, Electionguard includes a mechanism to decrypt with the Quorum of Guardians. During the Key Ceremony a Quorum of Guardians is defined that represents the minimum number of guardians that must be present to decrypt the election. If the decryption is to proceed with a Quorum of Guardians greater than or equal to the Quorum count, but less than the total number of guardians, then a subset of the Available Guardians must also each construct a Partial Decryption Share for the missing Missing Guardian, in addition to providing their own Decryption Share. It is important to note that mathematically not every present guardian has to compute a Partial Decryption Share for every Missing Guardian. Only the Quorum Count of guardians are necessary to construct Partial Decryption Shares in order to compensate for any Missing Guardian. In this implementation, ElectionGuard takes an approach that utilizes all Available Guardians to compensate for Missing Guardians. When it is determined that guardians are missing, all available guardians each calculate a Partial Decryption Share for the missing guardian and publish the result. A Quorum of Guardians count of available Partial Decryption Shares is randomly selected from the pool of available partial decryption shares for a givenMissing Guardian. If more than one guardian is missing, we randomly choose to ignore the Partial Decryption Share provided by one of the Available Guardians whose partial decryption share was chosen for the previous Missing Guardian, and randomly select again from the pool of available Partial Decryption Shares. This ensures that all available guardians have the opportunity to participate in compensating for Missing Guardians.","title":"Decryption"},{"location":"basics/steps/5_Publish_Record/","text":"Publish Record Publishing the election record helps ensure third parties can verify the election. publish.py provides a publish method that serializes the key election files. This makes use of the Serializable class exists to allow easy serializing to JSON files. These JSON files can then be shared and sent so others can verify.","title":"Publish Record"},{"location":"basics/steps/5_Publish_Record/#publish-record","text":"Publishing the election record helps ensure third parties can verify the election. publish.py provides a publish method that serializes the key election files. This makes use of the Serializable class exists to allow easy serializing to JSON files. These JSON files can then be shared and sent so others can verify.","title":"Publish Record"},{"location":"basics/steps/6_Verification/","text":"Verification Deserializing is the first step to verification. The from_json and from_json_file methods on Serializable are available to deserialize output JSON files back into their original classes.","title":"Verification"},{"location":"basics/steps/6_Verification/#verification","text":"Deserializing is the first step to verification. The from_json and from_json_file methods on Serializable are available to deserialize output JSON files back into their original classes.","title":"Verification"},{"location":"concepts/Homomorphic_Aggregation/","text":"Homomorphic Aggregation Work in Progress This is a work in progress. Feel free to contribute.","title":"Aggregation"},{"location":"concepts/Homomorphic_Aggregation/#homomorphic-aggregation","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Homomorphic Aggregation"},{"location":"concepts/Homomorphic_Encryption/","text":"Homomorphic Aggregation Work in Progress This is a work in progress. Feel free to contribute.","title":"Encryption"},{"location":"concepts/Homomorphic_Encryption/#homomorphic-aggregation","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Homomorphic Aggregation"},{"location":"concepts/Manifest_Building/","text":"Election Manifest There are many types of elections. We need a base set of data that shows how these different types of elections are handled in an ElectionGuard end-to-end verifiable election (or ballot comparison audits). We worked with InfernoRed, VotingWorks, and Dan Wallach of Rice University (thanks folks!) to develop a set of conventions, tests, and sample data (based on a starting dataset sample from the Center for Civic Design) that demonstrate how to encode the information necessary to conduct an election into a format that ElectionGuard can use. The election terms and structure are based whenever possible on the NIST SP-1500-100 Election Results Common Data Format Specification ( PDF ) and the Civics Common Standard Data Specification . The information captured by the NIST standard is codified into an election manifest that defines common elements when conducting an election, such as locations, candidates, parties, contests, and ballot styles. ElectionGuard uses the data contained in the Election Manifest to associate ballots with specific ballot styles and to verify the accuracy of data at different stages of the election process. Note that not all of the data contained in the Election Manifest impacts the computations of tallies and zero-knowledge proofs used in the published election data that demonstrates end-to-end verifiability; however it is important to include as much data as possible in order to distinguish one election from another. With a well-defined Election Manifest, improperly formatted ballot encryption requests will fail with error messages at the moment of initial encryption; the enforcement of any logic or behavior to prevent overvoting or other malformed ballot submissions are handled by the encrypting device, not ElectionGuard. In addition, since json files do not accommodate comments, all notations and exceptions are documented in this readme. Election Data Structure Elections are characterized into types by NIST as shown in the table below: election type description general For an election held typically on the national day for elections. partisan-primary-closed For a primary election that is for a specific party where voter eligibility is based on registration. partisan-primary-open For a primary election that is for a specific party where voter declares desired party or chooses in private. primary For a primary election without a specified type, such as a nonpartisan primary. runoff For an election to decide a prior contest that ended with no candidate receiving a majority of the votes. special For an election held out of sequence for special circumstances, for example, to fill a vacated office. other Used when the election type is not listed in this enumeration. If used, include a specific value of the OtherType element. We present two sample manifests: general and partisan-primary-closed . The core distinction between the two samples is the role of party: in general elections, voters can choose to vote for candidates from any party in a contest, regardless of party affiliation. In partisan primaries, voters can only vote in contests germane to their party declaration or affiliation. As such, special , runoff , and primary election types will follow the general pattern, and partisan-primary-open will follow the partisan-primary-closed pattern. Open primary elections can follow either pattern as determined by their governing rules and regulations. (As noted above, ElectionGuard expects properly-formed ballots; e.g., it would error and fail to encrypt a ballot in an open-primary-closed election if a contest with an incorrect party affiliation were submitted (as indicated by the ).) Ballot Styles and Geography At least in the United States, many complications are introduced by voting simultaneously on election contests that apply in specific geographies and jurisdictions. For example, a single election could include contests for congress, state assembly, school, and utility districts, each with their own geographic boundaries, many that do not respect town or county lines. The ElectionGuard Election Manifest data format is flexible to accommodate most situations, but it is usually up to the election commission and the external system to determine what each component of the manifest actually means. In the following examples, we will work through the process of defining different election types at a high level and describe the process of building the election manifest. Geographic and Ballot Style Breakdown Each election can be thought of as a list of contests that are relevant to a certain group of people in a specific place. In order to determine who is supposed to vote on which contests, we first need to define the geographic jurisdictions where the election is taking place. The NIST Guidelines present an excellent discussion of the geographic interplay of different contests. The diagram from page 12 is presented below. As the diagram shows, congressional, state assembly, school district and other geographic boundaries project onto towns and municipalities in different ways. Elections manage this complexity by creating unique ballot styles that present to voters only the contests that pertain to them. Different jurisdictions use terms such as wards, precincts, and districts to describe the areas of overlap that guide ballot style creation. We will use precinct but ward and district could be used instead. Contests, Candidates and Parties In most cases, a resident of a specific precinct or location will expect to see a certain list of contests that are relevant to them. A contest is a specific collection of available choices ( selections ) from which the voter may choose some subset. For the ElectionGuard Election Manifest, each possible selection in a contest must be associated with a candidate, even for Referendum-style contests. If a contest also supports write-in values, then a write-in candidate is also defined. Candidates may also be associated with specific parties, but this is not required for all election types. Introducing Hamilton County, OZ To help disambiguate, let's explore an example. Geographic Jurisdictions Hamilton County includes 3 townships: LaCroix, Arlington, Harris. The town of LaCroix also has a utility district that comprises its own precinct for special referendums. Arlington has two distinct school districts. The county is also split into two congressional districts, district 5 and district 7. Harris township is entirely within Congressional District 5, but both LaCroix and Arlington are split between congressional districts 5 and 7. ] Building the Geographic Jurisdiction Mapping (Geopolitical Units) The Election Manifest includes an array of objects called geopoliticalUnits (a.k.a. gpUnit ). Each Geopolitical Unit must include the following fields: objectId - a unique identifier for the gpUnit. This value is used to map a contest to a specific jurisdiction name - the friendly name of the gp Unit type - they type of jurisdiction (one of the Reporting Unit Types ) contact information - the contact info for the geopolitical unit Geopolitical units are polygons on a map represented by legal jurisdictions. In our example Election Manifest for hamilton County, there is one geopolitical unit for each jurisdictional boundary in the image above: Hamilton County Congressional District 5 congressional District 7 LaCroix Township Exeter Utility District (within LaCroix Township) Harris Township Arlington Township Pismo Beach School District (within Arlington Township) Somerset School District (within Arlington Township) When defining the geopolitical units for an election, we define all of the possible geopolitical units for an election; even if there are no contests for a specific jurisdiction. This way, if contests are added or removed during the setup phase, you do not also have to remember to update the list of geopolitical units. Alternatively, you can define only the GP Units for which there are contests. The General Election Contests A general election will occur in Hamilton County. The county is voting along with the rest of the province, and the county is responsible for tabulating its own election results. This means that the Election Scope is defined at the county level. For the general election, the following sets of contests (and associated geographic boundaries) obtain: The National Contests - President and Vice President. This contest demonstrates a \"vote for the ticket\" and allows write-ins Province Contests - Governor - this contest demonstrates a long list of candidate names Congressional Contests - Congress Districts 5 and 7 - these contests demonstrate how to split a district using multiple ballot styles Township Contests - Retain Chief Justice - This contest demonstrates a contest that applies to a specific town whose boundaries are split across multiple ballot styles School District Contests - School Board - these contests demonstrate contests with multiple selections ( n-of-m ) and allow write-ins School Board, and Utility district referendum to show ballot style splits Utility District Contest - Utility District - This contest demonstrates a referendum-style contest with long descriptions and display language translation into Spanish Each contest must be associated with exactly ONE electoralDistrictId . The electoralDistrictId field on the contest is populated with the objectId of the associated Geopolitical Unit (e.g. the Contest congress-district-7-contest has the electoralDistrictId congress-district-7 Each contest must also define a sequenceOrder . the sequence order is an indexing mechanism used internally. It is not the sequence that the contests are displayed to the user . The order in which contests are displayed to the user is up to the implementing application. The General Election Ballot Styles A ballot style is the set of contests that a specific voter should see on their ballot for a given location. The ballot style is associated to the set of geopolitical units relevant to a specific point on a map. Since each contest is also associated with a geopolitical unit, a mapping is created between a point on a map and the contests that are relevant to that point. For instance, a voter that lives in the Exeter Utility District should see contests that are relevant to Congressional District 7, LaCroix Township and the Exeter Utility District. | Geopolitical Units are overlapping polygons, and ballot styles are the list of polygons relevant to a specific point on the map. Similar to Geopolitical Units, we define all of the possible ballot styles for an election in our example, even if there are no contests specific to a ballot style. This is subjective and the behavior may be different for the integrating system: Congressional District 7 Outside Any Township Congressional District 7 LaCroix Township Congressional District 7 LaCroix Township Exeter Utility District Congressional District 7 Arlington Township Congressional District 7 Arlington Township Pismo Beach School district Congressional District 7 Arlington Township Somerset School district Congressional District 5 Outside Any Township Congressional District 5 LaCroix Township Congressional District 5 Harris Township Congressional District 5 Arlington Township Pismo Beach School district Congressional District 5 Arlington Township Somerset School district By defining all of the possible ballot styles and all of the possible geopolitical units, we ensure that if a contest is added or removed, we only have to make sure the contest is correct. We do not have to modify the list of geopolitical units or ballot styles. Data Flexibility The relationship between a ballot style and the contests that are displayed on it are subjective to the implementing application. This example is just one way to define this relationship that is purposefully verbose. For instance, in our example we define a geopolitical unit as a set of overlapping polygons, and a ballot style as the intersection of those polygons at a specific point. This is a top-down approach. Alternatively, we could have defined a geopolitical unit as the intersection area of those polygons and mapped one ballot style to each geopolitical unit 1 to 1. for instance, instead of defining a single GP Unit each for: Congressional District 5, Congressional District 7, LaCroix Township, Exeter Utility district, etc; we could have instead defined the GP Units as: Congressional District 5 No Township Congressional District 7 No Township Congressional District 5 inside LaCroix Congressional District 5 Inside LaCroix and Exeter, etc. Then, instead of each Ballot Style having multiple GP Units, each ballot style would have applied to exactly one GP Unit. Data Validation When the election Manifest is loaded into ElectionGuard, its validity is checked semantically against the data format required to conduct an ElectionGuard Election. Specifically, we check that: Each Geopolitical Unit has a unique objectId Each Ballot Style maps to at least one valid Geopolitical Unit Each Party has a unique objectId Each Candidate either does not have a party, or is associated with a valid party Each Contest has a unique Sequence Order Each Contest is associated with exactly one valid Geopolitical Unit Each Contest has a valid number of Selections for the number of seats in the contest Each Selection on each Contest is associated with a valid Candidate as long as the election manifest format matches the validation criteria, the election can proceed as an ElectionGuard election. Frequently Asked Questions Q: What if my ballot styles are not associated with geopolitical units? A: There are a few ways to handle this. In most cases, you can simply map the ballot style 1 to 1 to the geopolitical unit. for instance, if ballot-style-1 includes contest-1 then you may create geopolitical-unit-1 and associate both the ballot style and the contest to that geopolitical unit. This documentation is under review and subject to change. Please do not hesitate to open a github issue if you have questions, or find errors or omissions.","title":"Building"},{"location":"concepts/Manifest_Building/#election-manifest","text":"There are many types of elections. We need a base set of data that shows how these different types of elections are handled in an ElectionGuard end-to-end verifiable election (or ballot comparison audits). We worked with InfernoRed, VotingWorks, and Dan Wallach of Rice University (thanks folks!) to develop a set of conventions, tests, and sample data (based on a starting dataset sample from the Center for Civic Design) that demonstrate how to encode the information necessary to conduct an election into a format that ElectionGuard can use. The election terms and structure are based whenever possible on the NIST SP-1500-100 Election Results Common Data Format Specification ( PDF ) and the Civics Common Standard Data Specification . The information captured by the NIST standard is codified into an election manifest that defines common elements when conducting an election, such as locations, candidates, parties, contests, and ballot styles. ElectionGuard uses the data contained in the Election Manifest to associate ballots with specific ballot styles and to verify the accuracy of data at different stages of the election process. Note that not all of the data contained in the Election Manifest impacts the computations of tallies and zero-knowledge proofs used in the published election data that demonstrates end-to-end verifiability; however it is important to include as much data as possible in order to distinguish one election from another. With a well-defined Election Manifest, improperly formatted ballot encryption requests will fail with error messages at the moment of initial encryption; the enforcement of any logic or behavior to prevent overvoting or other malformed ballot submissions are handled by the encrypting device, not ElectionGuard. In addition, since json files do not accommodate comments, all notations and exceptions are documented in this readme.","title":"Election Manifest"},{"location":"concepts/Manifest_Building/#election-data-structure","text":"Elections are characterized into types by NIST as shown in the table below: election type description general For an election held typically on the national day for elections. partisan-primary-closed For a primary election that is for a specific party where voter eligibility is based on registration. partisan-primary-open For a primary election that is for a specific party where voter declares desired party or chooses in private. primary For a primary election without a specified type, such as a nonpartisan primary. runoff For an election to decide a prior contest that ended with no candidate receiving a majority of the votes. special For an election held out of sequence for special circumstances, for example, to fill a vacated office. other Used when the election type is not listed in this enumeration. If used, include a specific value of the OtherType element. We present two sample manifests: general and partisan-primary-closed . The core distinction between the two samples is the role of party: in general elections, voters can choose to vote for candidates from any party in a contest, regardless of party affiliation. In partisan primaries, voters can only vote in contests germane to their party declaration or affiliation. As such, special , runoff , and primary election types will follow the general pattern, and partisan-primary-open will follow the partisan-primary-closed pattern. Open primary elections can follow either pattern as determined by their governing rules and regulations. (As noted above, ElectionGuard expects properly-formed ballots; e.g., it would error and fail to encrypt a ballot in an open-primary-closed election if a contest with an incorrect party affiliation were submitted (as indicated by the ).)","title":"Election Data Structure"},{"location":"concepts/Manifest_Building/#ballot-styles-and-geography","text":"At least in the United States, many complications are introduced by voting simultaneously on election contests that apply in specific geographies and jurisdictions. For example, a single election could include contests for congress, state assembly, school, and utility districts, each with their own geographic boundaries, many that do not respect town or county lines. The ElectionGuard Election Manifest data format is flexible to accommodate most situations, but it is usually up to the election commission and the external system to determine what each component of the manifest actually means. In the following examples, we will work through the process of defining different election types at a high level and describe the process of building the election manifest.","title":"Ballot Styles and Geography"},{"location":"concepts/Manifest_Building/#geographic-and-ballot-style-breakdown","text":"Each election can be thought of as a list of contests that are relevant to a certain group of people in a specific place. In order to determine who is supposed to vote on which contests, we first need to define the geographic jurisdictions where the election is taking place. The NIST Guidelines present an excellent discussion of the geographic interplay of different contests. The diagram from page 12 is presented below. As the diagram shows, congressional, state assembly, school district and other geographic boundaries project onto towns and municipalities in different ways. Elections manage this complexity by creating unique ballot styles that present to voters only the contests that pertain to them. Different jurisdictions use terms such as wards, precincts, and districts to describe the areas of overlap that guide ballot style creation. We will use precinct but ward and district could be used instead.","title":"Geographic and Ballot Style Breakdown"},{"location":"concepts/Manifest_Building/#contests-candidates-and-parties","text":"In most cases, a resident of a specific precinct or location will expect to see a certain list of contests that are relevant to them. A contest is a specific collection of available choices ( selections ) from which the voter may choose some subset. For the ElectionGuard Election Manifest, each possible selection in a contest must be associated with a candidate, even for Referendum-style contests. If a contest also supports write-in values, then a write-in candidate is also defined. Candidates may also be associated with specific parties, but this is not required for all election types.","title":"Contests, Candidates and Parties"},{"location":"concepts/Manifest_Building/#introducing-hamilton-county-oz","text":"To help disambiguate, let's explore an example.","title":"Introducing Hamilton County, OZ"},{"location":"concepts/Manifest_Building/#geographic-jurisdictions","text":"Hamilton County includes 3 townships: LaCroix, Arlington, Harris. The town of LaCroix also has a utility district that comprises its own precinct for special referendums. Arlington has two distinct school districts. The county is also split into two congressional districts, district 5 and district 7. Harris township is entirely within Congressional District 5, but both LaCroix and Arlington are split between congressional districts 5 and 7. ]","title":"Geographic Jurisdictions"},{"location":"concepts/Manifest_Building/#building-the-geographic-jurisdiction-mapping-geopolitical-units","text":"The Election Manifest includes an array of objects called geopoliticalUnits (a.k.a. gpUnit ). Each Geopolitical Unit must include the following fields: objectId - a unique identifier for the gpUnit. This value is used to map a contest to a specific jurisdiction name - the friendly name of the gp Unit type - they type of jurisdiction (one of the Reporting Unit Types ) contact information - the contact info for the geopolitical unit Geopolitical units are polygons on a map represented by legal jurisdictions. In our example Election Manifest for hamilton County, there is one geopolitical unit for each jurisdictional boundary in the image above: Hamilton County Congressional District 5 congressional District 7 LaCroix Township Exeter Utility District (within LaCroix Township) Harris Township Arlington Township Pismo Beach School District (within Arlington Township) Somerset School District (within Arlington Township) When defining the geopolitical units for an election, we define all of the possible geopolitical units for an election; even if there are no contests for a specific jurisdiction. This way, if contests are added or removed during the setup phase, you do not also have to remember to update the list of geopolitical units. Alternatively, you can define only the GP Units for which there are contests.","title":"Building the Geographic Jurisdiction Mapping (Geopolitical Units)"},{"location":"concepts/Manifest_Building/#the-general-election-contests","text":"A general election will occur in Hamilton County. The county is voting along with the rest of the province, and the county is responsible for tabulating its own election results. This means that the Election Scope is defined at the county level. For the general election, the following sets of contests (and associated geographic boundaries) obtain: The National Contests - President and Vice President. This contest demonstrates a \"vote for the ticket\" and allows write-ins Province Contests - Governor - this contest demonstrates a long list of candidate names Congressional Contests - Congress Districts 5 and 7 - these contests demonstrate how to split a district using multiple ballot styles Township Contests - Retain Chief Justice - This contest demonstrates a contest that applies to a specific town whose boundaries are split across multiple ballot styles School District Contests - School Board - these contests demonstrate contests with multiple selections ( n-of-m ) and allow write-ins School Board, and Utility district referendum to show ballot style splits Utility District Contest - Utility District - This contest demonstrates a referendum-style contest with long descriptions and display language translation into Spanish Each contest must be associated with exactly ONE electoralDistrictId . The electoralDistrictId field on the contest is populated with the objectId of the associated Geopolitical Unit (e.g. the Contest congress-district-7-contest has the electoralDistrictId congress-district-7 Each contest must also define a sequenceOrder . the sequence order is an indexing mechanism used internally. It is not the sequence that the contests are displayed to the user . The order in which contests are displayed to the user is up to the implementing application.","title":"The General Election Contests"},{"location":"concepts/Manifest_Building/#the-general-election-ballot-styles","text":"A ballot style is the set of contests that a specific voter should see on their ballot for a given location. The ballot style is associated to the set of geopolitical units relevant to a specific point on a map. Since each contest is also associated with a geopolitical unit, a mapping is created between a point on a map and the contests that are relevant to that point. For instance, a voter that lives in the Exeter Utility District should see contests that are relevant to Congressional District 7, LaCroix Township and the Exeter Utility District. | Geopolitical Units are overlapping polygons, and ballot styles are the list of polygons relevant to a specific point on the map. Similar to Geopolitical Units, we define all of the possible ballot styles for an election in our example, even if there are no contests specific to a ballot style. This is subjective and the behavior may be different for the integrating system: Congressional District 7 Outside Any Township Congressional District 7 LaCroix Township Congressional District 7 LaCroix Township Exeter Utility District Congressional District 7 Arlington Township Congressional District 7 Arlington Township Pismo Beach School district Congressional District 7 Arlington Township Somerset School district Congressional District 5 Outside Any Township Congressional District 5 LaCroix Township Congressional District 5 Harris Township Congressional District 5 Arlington Township Pismo Beach School district Congressional District 5 Arlington Township Somerset School district By defining all of the possible ballot styles and all of the possible geopolitical units, we ensure that if a contest is added or removed, we only have to make sure the contest is correct. We do not have to modify the list of geopolitical units or ballot styles.","title":"The General Election Ballot Styles"},{"location":"concepts/Manifest_Building/#data-flexibility","text":"The relationship between a ballot style and the contests that are displayed on it are subjective to the implementing application. This example is just one way to define this relationship that is purposefully verbose. For instance, in our example we define a geopolitical unit as a set of overlapping polygons, and a ballot style as the intersection of those polygons at a specific point. This is a top-down approach. Alternatively, we could have defined a geopolitical unit as the intersection area of those polygons and mapped one ballot style to each geopolitical unit 1 to 1. for instance, instead of defining a single GP Unit each for: Congressional District 5, Congressional District 7, LaCroix Township, Exeter Utility district, etc; we could have instead defined the GP Units as: Congressional District 5 No Township Congressional District 7 No Township Congressional District 5 inside LaCroix Congressional District 5 Inside LaCroix and Exeter, etc. Then, instead of each Ballot Style having multiple GP Units, each ballot style would have applied to exactly one GP Unit.","title":"Data Flexibility"},{"location":"concepts/Manifest_Building/#data-validation","text":"When the election Manifest is loaded into ElectionGuard, its validity is checked semantically against the data format required to conduct an ElectionGuard Election. Specifically, we check that: Each Geopolitical Unit has a unique objectId Each Ballot Style maps to at least one valid Geopolitical Unit Each Party has a unique objectId Each Candidate either does not have a party, or is associated with a valid party Each Contest has a unique Sequence Order Each Contest is associated with exactly one valid Geopolitical Unit Each Contest has a valid number of Selections for the number of seats in the contest Each Selection on each Contest is associated with a valid Candidate as long as the election manifest format matches the validation criteria, the election can proceed as an ElectionGuard election.","title":"Data Validation"},{"location":"concepts/Manifest_Building/#frequently-asked-questions","text":"Q: What if my ballot styles are not associated with geopolitical units? A: There are a few ways to handle this. In most cases, you can simply map the ballot style 1 to 1 to the geopolitical unit. for instance, if ballot-style-1 includes contest-1 then you may create geopolitical-unit-1 and associate both the ballot style and the contest to that geopolitical unit. This documentation is under review and subject to change. Please do not hesitate to open a github issue if you have questions, or find errors or omissions.","title":"Frequently Asked Questions"},{"location":"concepts/Manifest_Example/","text":"Manifest Example Work in Progress This is a work in progress. Feel free to contribute.","title":"Example"},{"location":"concepts/Manifest_Example/#manifest-example","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Manifest Example"},{"location":"concepts/Structure_and_Processes/","text":"Structure and Processes ElectionGuard provides tools to enable end-to-end verifiable elections. This allows voters to check for themselves that their votes have been accurately counted. The ElectionGuard process has three principal components. Pre-election key generation Ballot encryption Post-election decryption of tallies Pre-Election Key Generation ElectionGuard utilizes Guardians to protect confidentiality of ballots. The Guardians independently generate public-private key pairs from public election parameters. flowchart TD A(\"Guardian T 1 (K 1 ,S 1 )\")-->B(K 1 ); C(\"Guardian T 2 (K 2 ,S 2 )\")-->D(K 2 ); E(\"Guardian T n (K n ,S n )\")-->F(K n ); style B fill:#FFFFFF00,stroke:#FFFFFF00 style D fill:#FFFFFF00,stroke:#FFFFFF00 style F fill:#FFFFFF00,stroke:#FFFFFF00 The individual public keys are then combined to form the election public key using simple multiplication. \\[ K=\\prod_{i=1}^{n} K_i \\] At this point in the process, the only way to decrypt data encrypted with the election public key K is for all n Guardians to individually apply their secret keys. This situation is fragile since a single missing Guardian will prevent an election from being completed. To remedy this, as the final pre-election step, the Guardians distribute to each other shares of their private keys. The sharing is done according to a pre-determined quorum parameter k and will allow any quorum set of k Guardians to complete a decryption. graph LR A(\"Guardian T 1 (K 1 ,S 1 )\")-->|S 1,2 |B(\"Guardian T 2 (K 2 ,S 2 )\"); B-->|S 2,1 |A; A-->|S 1,n |C(\"Guardian T n (K n ,S n )\"); B-->|S 2,n |C; C-->|S n,2 |B; C-->|S n,1 |A; Balot Encryption An encrypted ballot consists entirely of encryptions of zeros and ones. A simple clear form ballot with a single contest might look something like the following. \\[ \\braket{{\\color{RoyalBlue} 0,1,0,0}} \\] This would represent a ballot with a single contest in which the second of four options has been selected. The encrypted version of this ballot would consist of four encrypted values \\[ \\braket{C_1,C_2,C_3,C_4} \\] accompanied by \"proofs\" that each W_i is an encryption of either zero or one. But this is not enough to show that an encrypted ballot represents a legitimate vote because the clear form might be as follows. \\[ \\braket{{\\color{RoyalBlue} 0,1,0,1}} \\] The above ballot would indicate votes for both the second and fourth options, and this may not be allowed. To address this, we use the homomorphic property of the encryption which allows us to combine encryptions to produce an encryption of the sum. By using simple encryption, we can form a new encrypted value as \\[ C=\\prod_{i=1}^{4} C_i \\] and include a proof that this W is an encryption of one to show that the ballot doesn\u2019t include excessive votes. Placeholders This isn\u2019t quite everything we need, because a voter might choose to not vote in a contest. The resulting clear form of this ballot would look like the following. \\[ \\braket{{\\color{RoyalBlue} 0,0,0,0}} \\] If we were to homomorphically combine values in an encrypted form of this ballot, we would get an encryption of zero \u2013 not an encryption of one. We wouldn\u2019t want to reveal this fact, because even a voter who chooses not to vote deserves privacy. To address this, we add a placeholder option to each contest that can be thought of as a \"none of the above\" vote. So a contest with four options would be typically be represented by a ballot with five positions \u2013 with the fifth option set to one if the voter selects none of the four options offered. \\[ \\braket{{\\color{RoyalBlue} 0,0,0,0},{\\color{SkyBlue} 1}} \\] [Color changes are for exposition only.] Internally, a placeholder option looks no different from an ordinary option. But we can now ensure that a homomorphic combination of all of the encryptions on a ballot will be one. An encrypted ballot can now be shown to be legitimate by proving that each value is an encryption of either zero and one and the homomorphic combination of all of the encryptions in each contest is an encryption of one. \\[ \\braket{{\\color{RoyalBlue} 0,0,0,0},{\\color{SkyBlue} 1}} \\longrightarrow {\\color{DarkBlue} 1} \\] Some might recognize this as a \"map-reduce\" operation (or for those familiar with Kenneth Iverson's APL, a simple reduction operation). The operator applied to encrypted values is simple multiplication. But the effect is to produce an encryption of the sum of the clear form values. Selection Limits There is one further generalization that must be accommodated. In some elections, there are contests where a voter is allowed to select more than one option. For example, there might be five options of which a voter is allowed to select up to three. To accommodate this possibility, we note the selection limit for each contest and generalize the use of placeholders. In most elections, all or most contests will have a selection limit of one, and one placeholder option will be added to each such contest. However, if the selection limit is higher, additional placeholder values are added \u2013 with the total number of placeholders matching the selection limit. For example, a \"choose up to three of five\" contest will be captured with eight encrypted values, the first five of which match the selections that can be made by a voter, and the last three of which are placeholder values that can be set if a voter does not make the maximum number of selections. The following offers some examples of how the clear form of a choose three of five ballot might be set. \\[\\begin{align} \\braket{{\\color{RoyalBlue} 1,0,0,1,1,}{\\color{SkyBlue}0,0,0}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue} 0,1,1,0,1,}{\\color{SkyBlue}0,0,0}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue} 1,0,0,1,0,}{\\color{SkyBlue} 0,0,1}}\\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue} 0,0,0,1,0,}{\\color{SkyBlue} 0,1,1}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue}0,0,0,0,0,}{\\color{SkyBlue} 1,1,1}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\end{align}\\] [Color changes are for exposition only.] The first two instance represent ballots in which all three allowed votes have been used; the next instance shows a ballot in which only two options were selected; the following ballot instance contains one selection (and two placeholders set); and the final instance shows a case when a voter has made no selections and all three placeholders are used. In all of the above examples, an associated encrypted ballot is shown to be legitimate by showing that every value is an encryption of zero or one and the homomorphic combination of all of the encryptions produces an encryption of three. Write-in Votes ElectionGuard currently does not distinguish between write-ins. If a write-in option is offered, ElectionGuard treats it as any other selection. ElectionGuard tallies the number of write-ins for any contest without indicating what was written in. Multiple Contests Most elections consist of more than a single contest. A single ballot can therefore include multiple contests. An encrypted ballot still consists entirely of encryptions of zeros and ones, but the interpretation of these encryptions and the accompanying proofs depend upon details provided in the ballot manifest. \\[ \\braket{{\\color{RoyalBlue} 0,1,0,}{\\color{SkyBlue} 0};{\\color{ForestGreen} 1,0,}{\\color{YellowGreen} 0};{\\color{RoyalBlue} 0,0,}{\\color{SkyBlue} 1};{\\color{ForestGreen} 1,0,1,0,0,}{\\color{YellowGreen} 0,0,1}} \\] [Color changes are for exposition only.] The above example shows a clear form of a ballot with four contests in which the second of three options is selected in the first contest (with the fourth position as an unused placeholder), the first of two options is chosen in the second contest (with the third position as an unused placeholder), neither of two options is selected in the third contest (with the placeholder set to one), and the first and third option selected in a \"three of five\" fourth contest with one of three placeholders set to one. The encrypted form of the example above should be accompanied by proofs that all eighteen of the components are encryptions of zero or one, that the first four encryptions homomorphically combine to form an encryption of one, the next three encryptions homomorphically combine to form an encryption of one, the following three encryptions homomorphically combine to form an encryption of one, and the final eight encryptions homomorphically combine to form an encryption of three. Post-Election Decryption of Tallies When an election is complete, there will be a set of encrypted ballots that have been cast by voters and will be published in the election record. The homomorphic property that is used within individual ballots to show that the number of selected options for each contest is correct can also be used across ballots to compute tallies. For example, suppose that the five clear form ballots shown above as samples in a choose-three-of-five contest represent actual ballots cast in an election. \\[\\begin{align} \\braket{{\\color{RoyalBlue} 1,0,0,1,1,}{\\color{SkyBlue} 0,0,0}} \\\\ \\braket{{\\color{RoyalBlue} 0,1,1,0,1,}{\\color{SkyBlue} 0,0,0}} \\\\ \\braket{{\\color{RoyalBlue} 1,0,0,1,0,}{\\color{SkyBlue} 0,0,1}} \\\\ \\braket{{\\color{RoyalBlue} 0,0,0,1,0,}{\\color{SkyBlue} 0,1,1}} \\\\ \\braket{{\\color{RoyalBlue} 0,0,0,0,0,}{\\color{SkyBlue} 1,1,1}} \\\\ \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\\\ \\braket{{\\color{RoyalBlue} 2,1,1,3,2,}{\\color{SkyBlue} 1,2,3}} \\\\ \\end{align}\\] Verifiable Decryption Guardians can each apply their private keys to an encrypted value to perform a partial decryption. graph TD A(\"Guardian T 1 (K 1 ,S 1 )\")-->B(M 1 ); C(\"Guardian T 2 (K 2 ,S 2 )\")-->D(M 2 ); A1(C)-->A; C1(C)-->C; E(\"Guardian T n (K n ,S n )\")-->F(M n ); E1(C)-->E; style B fill:#FFFFFF00,stroke:#FFFFFF00 style D fill:#FFFFFF00,stroke:#FFFFFF00 style C1 fill:#FFFFFF00,stroke:#FFFFFF00 style A1 fill:#FFFFFF00,stroke:#FFFFFF00 style E1 fill:#FFFFFF00,stroke:#FFFFFF00 style F fill:#FFFFFF00,stroke:#FFFFFF00 The partial decryptions \\(M_i\\) can be combined \u2013 again using ordinary multiplication \u2013 to form the full decryption. \\[ M = \\prod _{i=1} ^n M_i \\] Together with each partial decryption, each guardian produces additional data that can be used by observers to very that the decryptions are correct. Missing Guardians If one or more Guardians are missing during a decryption, a quorum of any \\(k\\) available Guardians can form the partial decryption of the missing Guardian. graph TD A(\"Guardian T i 1 S j,i 1 \")-->B(M j,i 1 ); C(\"Guardian T i 2 S j,i 2 \")-->D(M j,i 2 ); A1(C)-->A; C1(C)-->C; E(\"Guardian T i k S j,i k \")-->F(M j,i k ); E1(C)-->E; style B fill:#FFFFFF00,stroke:#FFFFFF00 style D fill:#FFFFFF00,stroke:#FFFFFF00 style C1 fill:#FFFFFF00,stroke:#FFFFFF00 style A1 fill:#FFFFFF00,stroke:#FFFFFF00 style E1 fill:#FFFFFF00,stroke:#FFFFFF00 style F fill:#FFFFFF00,stroke:#FFFFFF00 The \\(k\\) values \\(M_{j,i_{1}},M_{j,i_{2}}, ... ,M_{j,i_{k}},\\) can be combined to calculate the missing partial decryption. In this way, an aggregate ballot can be fully and verifiably decrypted by any quorum set of \\(k\\) Guardians. Casting and Spoiling Voters need to be provided with a mechanism to encrypt their selections and have confidence that their selections have been correctly encrypted. The process used by ElectionGuard is to encrypt ballots as instructed by voters and then to allow voters to optionally spoil encrypted ballots. A spoiled ballot is verifiably decrypted (as with the aggregate ballot above), and the voter is given the opportunity to cast a new ballot. graph TD id[Make Selections]-->id1[Have Ballot Encrypted]; id1-->id2[Choose Cast or Spoil]; id2-->|Cast| id3[Record Encrypted Ballot as Cast]; id2-->|Spoil| id4[Decrypt Ballot and Record it as Spoiled]; id4-->id; The Election Record Once voting is complete, an election record is published containing all of the following artifacts. All cast encrypted ballot Proofs that all cast encrypted ballots are properly formed A tally ballot formed as the homomorphic aggregation of all cast ballots A verifiable decryption of the tally ballot All spoiled ballots Verifiable decryptions of all spoiled ballots Cast Ballots: #tb1 td{ border-width:0.5px; border-style:solid; border-color:#3d414b; text-align: center; vertical-align: middle } #tb1 th{ border-width:0.5px;border-style:solid; text-align: center; border-color:#3d414b; vertical-align: middle; height:20px } .hd{text-align:center;vertical-align:top} .em{background-color:#0E84EE} .lm{background-color:#1fccff} #tb1 #rm .em{border-left:none;border-right:none;background-color:transparent} Contest1 Contest2 Contest3 Encrypted Ballot 1 Proof of Correct Form Encrypted Ballot 2 Proof of Correct Form Encrypted Ballot 3 Proof of Correct Form Encrypted Ballot 4 Proof of Correct Form Encrypted Ballot 5 Proof of Correct Form Encrypted Ballot 6 Proof of Correct Form x x x x x x x x x x x x Encrypted Tally Decrypted Tally 3 1 2 1 2 3 0 2 2 1 1 3 Proof of Correct Decryption Spoiled Ballot 1: table td{ border-width:0.5px; border-style:solid; border-color:#3d414b; text-align: center; vertical-align: middle } table th{ border-width:0.5px;border-style:solid; text-align: center; border-color:#3d414b; vertical-align: middle; height:20px } Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 0 1 0 0 1 0 0 0 0 0 0 1 Proof of Correct Decryption Spoiled Ballot 2: Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 1 0 0 0 0 0 1 1 1 0 0 0 Proof of Correct Decryption Spoiled Ballot 3: Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 1 0 0 0 0 0 0 1 0 0 0 1 Proof of Correct Decryption Spoiled Ballot 4: Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 0 0 1 0 0 1 0 0 0 1 0 0 Proof of Correct Decryption Verification Voters are able to verify that their own ballots have been correctly recorded by utilizing the ballot spoiling process described above. Anyone can verify that recorded ballots have been accurately tallied by verifying the following items. For each cast ballot, the proof that the ballot is properly formed The tally ballot is the homomorphic aggregation of all cast ballots The proof that the aggregate tally ballot has been correctly decrypted In addition, the election record contains spoiled ballots for which the following should be verified. The proof of the correct decryption of each spoiled ballot Each spoiled ballot is properly formed (this can be done by checking proofs of proper formation or simply by inspecting the decryption) Although logically, the verification of correct decryption of spoiled ballots can be done by the individual voters who spoiled those ballots as part of the verification of correct recording; practically, this process closely matches the process of verifying correct decryption of the aggregate tally ballot. By transferring this responsibility to those verifying the election record, voters who want to verify correct recording of their ballots can be relieved of the responsibility of writing/executing code to check the decryption arithmetic and can instead check merely whether the claimed decryptions of spoiled ballots match their expectations.","title":"Structures and Processes"},{"location":"concepts/Structure_and_Processes/#structure-and-processes","text":"ElectionGuard provides tools to enable end-to-end verifiable elections. This allows voters to check for themselves that their votes have been accurately counted. The ElectionGuard process has three principal components. Pre-election key generation Ballot encryption Post-election decryption of tallies","title":"Structure and Processes"},{"location":"concepts/Structure_and_Processes/#pre-election-key-generation","text":"ElectionGuard utilizes Guardians to protect confidentiality of ballots. The Guardians independently generate public-private key pairs from public election parameters. flowchart TD A(\"Guardian T 1 (K 1 ,S 1 )\")-->B(K 1 ); C(\"Guardian T 2 (K 2 ,S 2 )\")-->D(K 2 ); E(\"Guardian T n (K n ,S n )\")-->F(K n ); style B fill:#FFFFFF00,stroke:#FFFFFF00 style D fill:#FFFFFF00,stroke:#FFFFFF00 style F fill:#FFFFFF00,stroke:#FFFFFF00 The individual public keys are then combined to form the election public key using simple multiplication. \\[ K=\\prod_{i=1}^{n} K_i \\] At this point in the process, the only way to decrypt data encrypted with the election public key K is for all n Guardians to individually apply their secret keys. This situation is fragile since a single missing Guardian will prevent an election from being completed. To remedy this, as the final pre-election step, the Guardians distribute to each other shares of their private keys. The sharing is done according to a pre-determined quorum parameter k and will allow any quorum set of k Guardians to complete a decryption. graph LR A(\"Guardian T 1 (K 1 ,S 1 )\")-->|S 1,2 |B(\"Guardian T 2 (K 2 ,S 2 )\"); B-->|S 2,1 |A; A-->|S 1,n |C(\"Guardian T n (K n ,S n )\"); B-->|S 2,n |C; C-->|S n,2 |B; C-->|S n,1 |A;","title":"Pre-Election Key Generation"},{"location":"concepts/Structure_and_Processes/#balot-encryption","text":"An encrypted ballot consists entirely of encryptions of zeros and ones. A simple clear form ballot with a single contest might look something like the following. \\[ \\braket{{\\color{RoyalBlue} 0,1,0,0}} \\] This would represent a ballot with a single contest in which the second of four options has been selected. The encrypted version of this ballot would consist of four encrypted values \\[ \\braket{C_1,C_2,C_3,C_4} \\] accompanied by \"proofs\" that each W_i is an encryption of either zero or one. But this is not enough to show that an encrypted ballot represents a legitimate vote because the clear form might be as follows. \\[ \\braket{{\\color{RoyalBlue} 0,1,0,1}} \\] The above ballot would indicate votes for both the second and fourth options, and this may not be allowed. To address this, we use the homomorphic property of the encryption which allows us to combine encryptions to produce an encryption of the sum. By using simple encryption, we can form a new encrypted value as \\[ C=\\prod_{i=1}^{4} C_i \\] and include a proof that this W is an encryption of one to show that the ballot doesn\u2019t include excessive votes.","title":"Balot Encryption"},{"location":"concepts/Structure_and_Processes/#placeholders","text":"This isn\u2019t quite everything we need, because a voter might choose to not vote in a contest. The resulting clear form of this ballot would look like the following. \\[ \\braket{{\\color{RoyalBlue} 0,0,0,0}} \\] If we were to homomorphically combine values in an encrypted form of this ballot, we would get an encryption of zero \u2013 not an encryption of one. We wouldn\u2019t want to reveal this fact, because even a voter who chooses not to vote deserves privacy. To address this, we add a placeholder option to each contest that can be thought of as a \"none of the above\" vote. So a contest with four options would be typically be represented by a ballot with five positions \u2013 with the fifth option set to one if the voter selects none of the four options offered. \\[ \\braket{{\\color{RoyalBlue} 0,0,0,0},{\\color{SkyBlue} 1}} \\] [Color changes are for exposition only.] Internally, a placeholder option looks no different from an ordinary option. But we can now ensure that a homomorphic combination of all of the encryptions on a ballot will be one. An encrypted ballot can now be shown to be legitimate by proving that each value is an encryption of either zero and one and the homomorphic combination of all of the encryptions in each contest is an encryption of one. \\[ \\braket{{\\color{RoyalBlue} 0,0,0,0},{\\color{SkyBlue} 1}} \\longrightarrow {\\color{DarkBlue} 1} \\] Some might recognize this as a \"map-reduce\" operation (or for those familiar with Kenneth Iverson's APL, a simple reduction operation). The operator applied to encrypted values is simple multiplication. But the effect is to produce an encryption of the sum of the clear form values.","title":"Placeholders"},{"location":"concepts/Structure_and_Processes/#selection-limits","text":"There is one further generalization that must be accommodated. In some elections, there are contests where a voter is allowed to select more than one option. For example, there might be five options of which a voter is allowed to select up to three. To accommodate this possibility, we note the selection limit for each contest and generalize the use of placeholders. In most elections, all or most contests will have a selection limit of one, and one placeholder option will be added to each such contest. However, if the selection limit is higher, additional placeholder values are added \u2013 with the total number of placeholders matching the selection limit. For example, a \"choose up to three of five\" contest will be captured with eight encrypted values, the first five of which match the selections that can be made by a voter, and the last three of which are placeholder values that can be set if a voter does not make the maximum number of selections. The following offers some examples of how the clear form of a choose three of five ballot might be set. \\[\\begin{align} \\braket{{\\color{RoyalBlue} 1,0,0,1,1,}{\\color{SkyBlue}0,0,0}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue} 0,1,1,0,1,}{\\color{SkyBlue}0,0,0}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue} 1,0,0,1,0,}{\\color{SkyBlue} 0,0,1}}\\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue} 0,0,0,1,0,}{\\color{SkyBlue} 0,1,1}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue}0,0,0,0,0,}{\\color{SkyBlue} 1,1,1}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\end{align}\\] [Color changes are for exposition only.] The first two instance represent ballots in which all three allowed votes have been used; the next instance shows a ballot in which only two options were selected; the following ballot instance contains one selection (and two placeholders set); and the final instance shows a case when a voter has made no selections and all three placeholders are used. In all of the above examples, an associated encrypted ballot is shown to be legitimate by showing that every value is an encryption of zero or one and the homomorphic combination of all of the encryptions produces an encryption of three.","title":"Selection Limits"},{"location":"concepts/Structure_and_Processes/#write-in-votes","text":"ElectionGuard currently does not distinguish between write-ins. If a write-in option is offered, ElectionGuard treats it as any other selection. ElectionGuard tallies the number of write-ins for any contest without indicating what was written in.","title":"Write-in Votes"},{"location":"concepts/Structure_and_Processes/#multiple-contests","text":"Most elections consist of more than a single contest. A single ballot can therefore include multiple contests. An encrypted ballot still consists entirely of encryptions of zeros and ones, but the interpretation of these encryptions and the accompanying proofs depend upon details provided in the ballot manifest. \\[ \\braket{{\\color{RoyalBlue} 0,1,0,}{\\color{SkyBlue} 0};{\\color{ForestGreen} 1,0,}{\\color{YellowGreen} 0};{\\color{RoyalBlue} 0,0,}{\\color{SkyBlue} 1};{\\color{ForestGreen} 1,0,1,0,0,}{\\color{YellowGreen} 0,0,1}} \\] [Color changes are for exposition only.] The above example shows a clear form of a ballot with four contests in which the second of three options is selected in the first contest (with the fourth position as an unused placeholder), the first of two options is chosen in the second contest (with the third position as an unused placeholder), neither of two options is selected in the third contest (with the placeholder set to one), and the first and third option selected in a \"three of five\" fourth contest with one of three placeholders set to one. The encrypted form of the example above should be accompanied by proofs that all eighteen of the components are encryptions of zero or one, that the first four encryptions homomorphically combine to form an encryption of one, the next three encryptions homomorphically combine to form an encryption of one, the following three encryptions homomorphically combine to form an encryption of one, and the final eight encryptions homomorphically combine to form an encryption of three.","title":"Multiple Contests"},{"location":"concepts/Structure_and_Processes/#post-election-decryption-of-tallies","text":"When an election is complete, there will be a set of encrypted ballots that have been cast by voters and will be published in the election record. The homomorphic property that is used within individual ballots to show that the number of selected options for each contest is correct can also be used across ballots to compute tallies. For example, suppose that the five clear form ballots shown above as samples in a choose-three-of-five contest represent actual ballots cast in an election. \\[\\begin{align} \\braket{{\\color{RoyalBlue} 1,0,0,1,1,}{\\color{SkyBlue} 0,0,0}} \\\\ \\braket{{\\color{RoyalBlue} 0,1,1,0,1,}{\\color{SkyBlue} 0,0,0}} \\\\ \\braket{{\\color{RoyalBlue} 1,0,0,1,0,}{\\color{SkyBlue} 0,0,1}} \\\\ \\braket{{\\color{RoyalBlue} 0,0,0,1,0,}{\\color{SkyBlue} 0,1,1}} \\\\ \\braket{{\\color{RoyalBlue} 0,0,0,0,0,}{\\color{SkyBlue} 1,1,1}} \\\\ \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\\\ \\braket{{\\color{RoyalBlue} 2,1,1,3,2,}{\\color{SkyBlue} 1,2,3}} \\\\ \\end{align}\\]","title":"Post-Election Decryption of Tallies"},{"location":"concepts/Structure_and_Processes/#verifiable-decryption","text":"Guardians can each apply their private keys to an encrypted value to perform a partial decryption. graph TD A(\"Guardian T 1 (K 1 ,S 1 )\")-->B(M 1 ); C(\"Guardian T 2 (K 2 ,S 2 )\")-->D(M 2 ); A1(C)-->A; C1(C)-->C; E(\"Guardian T n (K n ,S n )\")-->F(M n ); E1(C)-->E; style B fill:#FFFFFF00,stroke:#FFFFFF00 style D fill:#FFFFFF00,stroke:#FFFFFF00 style C1 fill:#FFFFFF00,stroke:#FFFFFF00 style A1 fill:#FFFFFF00,stroke:#FFFFFF00 style E1 fill:#FFFFFF00,stroke:#FFFFFF00 style F fill:#FFFFFF00,stroke:#FFFFFF00 The partial decryptions \\(M_i\\) can be combined \u2013 again using ordinary multiplication \u2013 to form the full decryption. \\[ M = \\prod _{i=1} ^n M_i \\] Together with each partial decryption, each guardian produces additional data that can be used by observers to very that the decryptions are correct.","title":"Verifiable Decryption"},{"location":"concepts/Structure_and_Processes/#missing-guardians","text":"If one or more Guardians are missing during a decryption, a quorum of any \\(k\\) available Guardians can form the partial decryption of the missing Guardian. graph TD A(\"Guardian T i 1 S j,i 1 \")-->B(M j,i 1 ); C(\"Guardian T i 2 S j,i 2 \")-->D(M j,i 2 ); A1(C)-->A; C1(C)-->C; E(\"Guardian T i k S j,i k \")-->F(M j,i k ); E1(C)-->E; style B fill:#FFFFFF00,stroke:#FFFFFF00 style D fill:#FFFFFF00,stroke:#FFFFFF00 style C1 fill:#FFFFFF00,stroke:#FFFFFF00 style A1 fill:#FFFFFF00,stroke:#FFFFFF00 style E1 fill:#FFFFFF00,stroke:#FFFFFF00 style F fill:#FFFFFF00,stroke:#FFFFFF00 The \\(k\\) values \\(M_{j,i_{1}},M_{j,i_{2}}, ... ,M_{j,i_{k}},\\) can be combined to calculate the missing partial decryption. In this way, an aggregate ballot can be fully and verifiably decrypted by any quorum set of \\(k\\) Guardians.","title":"Missing Guardians"},{"location":"concepts/Structure_and_Processes/#casting-and-spoiling","text":"Voters need to be provided with a mechanism to encrypt their selections and have confidence that their selections have been correctly encrypted. The process used by ElectionGuard is to encrypt ballots as instructed by voters and then to allow voters to optionally spoil encrypted ballots. A spoiled ballot is verifiably decrypted (as with the aggregate ballot above), and the voter is given the opportunity to cast a new ballot. graph TD id[Make Selections]-->id1[Have Ballot Encrypted]; id1-->id2[Choose Cast or Spoil]; id2-->|Cast| id3[Record Encrypted Ballot as Cast]; id2-->|Spoil| id4[Decrypt Ballot and Record it as Spoiled]; id4-->id;","title":"Casting and Spoiling"},{"location":"concepts/Structure_and_Processes/#the-election-record","text":"Once voting is complete, an election record is published containing all of the following artifacts. All cast encrypted ballot Proofs that all cast encrypted ballots are properly formed A tally ballot formed as the homomorphic aggregation of all cast ballots A verifiable decryption of the tally ballot All spoiled ballots Verifiable decryptions of all spoiled ballots Cast Ballots: #tb1 td{ border-width:0.5px; border-style:solid; border-color:#3d414b; text-align: center; vertical-align: middle } #tb1 th{ border-width:0.5px;border-style:solid; text-align: center; border-color:#3d414b; vertical-align: middle; height:20px } .hd{text-align:center;vertical-align:top} .em{background-color:#0E84EE} .lm{background-color:#1fccff} #tb1 #rm .em{border-left:none;border-right:none;background-color:transparent} Contest1 Contest2 Contest3 Encrypted Ballot 1 Proof of Correct Form Encrypted Ballot 2 Proof of Correct Form Encrypted Ballot 3 Proof of Correct Form Encrypted Ballot 4 Proof of Correct Form Encrypted Ballot 5 Proof of Correct Form Encrypted Ballot 6 Proof of Correct Form x x x x x x x x x x x x Encrypted Tally Decrypted Tally 3 1 2 1 2 3 0 2 2 1 1 3 Proof of Correct Decryption Spoiled Ballot 1: table td{ border-width:0.5px; border-style:solid; border-color:#3d414b; text-align: center; vertical-align: middle } table th{ border-width:0.5px;border-style:solid; text-align: center; border-color:#3d414b; vertical-align: middle; height:20px } Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 0 1 0 0 1 0 0 0 0 0 0 1 Proof of Correct Decryption Spoiled Ballot 2: Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 1 0 0 0 0 0 1 1 1 0 0 0 Proof of Correct Decryption Spoiled Ballot 3: Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 1 0 0 0 0 0 0 1 0 0 0 1 Proof of Correct Decryption Spoiled Ballot 4: Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 0 0 1 0 0 1 0 0 0 1 0 0 Proof of Correct Decryption","title":"The Election Record"},{"location":"concepts/Structure_and_Processes/#verification","text":"Voters are able to verify that their own ballots have been correctly recorded by utilizing the ballot spoiling process described above. Anyone can verify that recorded ballots have been accurately tallied by verifying the following items. For each cast ballot, the proof that the ballot is properly formed The tally ballot is the homomorphic aggregation of all cast ballots The proof that the aggregate tally ballot has been correctly decrypted In addition, the election record contains spoiled ballots for which the following should be verified. The proof of the correct decryption of each spoiled ballot Each spoiled ballot is properly formed (this can be done by checking proofs of proper formation or simply by inspecting the decryption) Although logically, the verification of correct decryption of spoiled ballots can be done by the individual voters who spoiled those ballots as part of the verification of correct recording; practically, this process closely matches the process of verifying correct decryption of the aggregate tally ballot. By transferring this responsibility to those verifying the election record, voters who want to verify correct recording of their ballots can be relieved of the responsibility of writing/executing code to check the decryption arithmetic and can instead check merely whether the claimed decryptions of spoiled ballots match their expectations.","title":"Verification"},{"location":"concepts/Verifiability/","text":"Creating a Verifiable Election ElectionGuard is a software development kit (SDK) election system vendors can use to implement end-to-end verifiable (E2E-V) elections. Because it is designed to be integrated into both existing and new systems, it needs to be flexible. However, for end-to-end verifiability to be achieved, the following 3 core capabilities must be delivered: The voter is given a verification code they can use to verify their ballot was included in the final tally The voter has the means to challenge a ballot The election results and all its encrypted artifacts, including zero knowledge proofs, are published to enable full independent verifiability by third parties We describe each of these capabilities in detail below. Voter Verification Code A voter verification code is generated by the ballot encryption process of ElectionGuard. It is generated when the user has submitted their ballot to the voting system. Generating the Verification Code Submitting a ballot can mean virtually pressing a \"Submit\" button on a touchscreen voting device, inserting a paper ballot into a digital scanner, or some other event that causes a cast vote record to be generated in the voting system. From a user experience standpoint, the ballot encryption occurs at a point after the voter has filled out all contests they plan to, and has had a chance to review all their choices in a summary screen (or the completed paper ballot). In the ballot marking device use case, the ballot would be encrypted after the voter presses submit. For a ballot scanner, the cast vote record is generated after the scanner has interpreted the ballot. Please note that while the diagrams above show devices such as 'encrypted ballot server', ElectionGuard is intended to be run in an offline environment ; as such, if an API or server is used to listen for or communicate encryption requests, they are expected to be run locally in a secure environment. Once the ballot has been encrypted, the encrypting device needs to handle the verification code returned by the ballot encryption process and present it to the voter, ideally by printing it at the moment of creation in a format easy for the voter to take with them. When the election results are published (see \"Publishing election results\" below), these verification codes are published alongside, enabling them to see that their ballots were included in the election tally (or, in the case of Challenge Ballots, that they were included as challenge ballots (see \"Challenging a Ballot\" below)) The verification code format is a mix of human-readable words and alphanumeric codes. The first word is always human-readable to facilitate a search-like discovery experience (to try, go to our demo tracking site and begin typing 'coo' to surface the verification code above, or simply click the image to be taken directly). Challenging a ballot Encrypting a ballot and generating a verification code is the first step in an E2E-V process for the voter. For E2E-V compliance, the voter has to be offered the ability to challenge or \"spoil\" the ballot after the verification code has been generated and provided to the voter. When a ballot is challenged, it is no longer eligible to be included in the final tally. If the voter wants to register a vote after a challenge, they will need to begin the process again with a new ballot. In addition, when a ballot is challenged, the system must be able to perform a decryption of the challenged ballot and reveal its contents to the voter. Challenging of ballots increases the inherent security of the system, since the system has to assume that any ballot encrypted might have to be revealed, exposing any manipulation that may have occurred after submission; the system can't assume its actions will remain hidden. Individual voters can obtain as much confidence as they desire by challenging as many ballots as they wish. Although they won't ever be shown that the encryption of a cast ballot matches their selections, voters can see that every challenged ballot was correctly encrypted and committed to before the decision to cast or challenge was made. The ability to observe that all challenge ballots are correct thereby provides indirect evidence that cast ballots were also correct. Publishing Verifiable results When the election is complete and the results tallied, E2E-V elections publish the results so they can be verified independently. E2E-V election verifiers are written by third parties according to their interpretation of the ElectionGuard Specification . Any data published by an election should enable each and every cast encrypted ballot to be interrogated and tallied independently. From the spec: An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). Two things must be proven about the encryption of each vote: The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in a contest is equal to the selection limit for that contest (usually one). ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. Chaum-Pedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013 particularly that a value is an encryption of either zero or one. The set of encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit, again using a Chaum-Pedersen proof. Once every ballot is proven to be properly formed (as above), all of the votes for each option are homomorphically summed to produce encryptions of the tallies for each option. The final step is then to decrypt these tallies and provide additional proofs that the decryption are correct. Showing Verification Code Results to Voters In addition to satisfying the data requirements for proper verification, any publishing exercise needs to also enable individual voters to query for the ballot that matches their verification code. Verification code results of cast ballots will indicate that the ballot was included in the final tally, and any associated metadata about the device that recorded the ballot (time, location, election, etc.; see example above). Challenge ballots are also published. Results for verification codes of challenge ballots should indicate that the ballot was not included in the election tally. Because the ballot is not included in the election tally, the contents can be decrypted and presented as well.","title":"Introduction"},{"location":"concepts/Verifiability/#creating-a-verifiable-election","text":"ElectionGuard is a software development kit (SDK) election system vendors can use to implement end-to-end verifiable (E2E-V) elections. Because it is designed to be integrated into both existing and new systems, it needs to be flexible. However, for end-to-end verifiability to be achieved, the following 3 core capabilities must be delivered: The voter is given a verification code they can use to verify their ballot was included in the final tally The voter has the means to challenge a ballot The election results and all its encrypted artifacts, including zero knowledge proofs, are published to enable full independent verifiability by third parties We describe each of these capabilities in detail below.","title":"Creating a Verifiable Election"},{"location":"concepts/Verifiability/#voter-verification-code","text":"A voter verification code is generated by the ballot encryption process of ElectionGuard. It is generated when the user has submitted their ballot to the voting system.","title":"Voter Verification Code"},{"location":"concepts/Verifiability/#generating-the-verification-code","text":"Submitting a ballot can mean virtually pressing a \"Submit\" button on a touchscreen voting device, inserting a paper ballot into a digital scanner, or some other event that causes a cast vote record to be generated in the voting system. From a user experience standpoint, the ballot encryption occurs at a point after the voter has filled out all contests they plan to, and has had a chance to review all their choices in a summary screen (or the completed paper ballot). In the ballot marking device use case, the ballot would be encrypted after the voter presses submit. For a ballot scanner, the cast vote record is generated after the scanner has interpreted the ballot. Please note that while the diagrams above show devices such as 'encrypted ballot server', ElectionGuard is intended to be run in an offline environment ; as such, if an API or server is used to listen for or communicate encryption requests, they are expected to be run locally in a secure environment. Once the ballot has been encrypted, the encrypting device needs to handle the verification code returned by the ballot encryption process and present it to the voter, ideally by printing it at the moment of creation in a format easy for the voter to take with them. When the election results are published (see \"Publishing election results\" below), these verification codes are published alongside, enabling them to see that their ballots were included in the election tally (or, in the case of Challenge Ballots, that they were included as challenge ballots (see \"Challenging a Ballot\" below)) The verification code format is a mix of human-readable words and alphanumeric codes. The first word is always human-readable to facilitate a search-like discovery experience (to try, go to our demo tracking site and begin typing 'coo' to surface the verification code above, or simply click the image to be taken directly).","title":"Generating the Verification Code"},{"location":"concepts/Verifiability/#challenging-a-ballot","text":"Encrypting a ballot and generating a verification code is the first step in an E2E-V process for the voter. For E2E-V compliance, the voter has to be offered the ability to challenge or \"spoil\" the ballot after the verification code has been generated and provided to the voter. When a ballot is challenged, it is no longer eligible to be included in the final tally. If the voter wants to register a vote after a challenge, they will need to begin the process again with a new ballot. In addition, when a ballot is challenged, the system must be able to perform a decryption of the challenged ballot and reveal its contents to the voter. Challenging of ballots increases the inherent security of the system, since the system has to assume that any ballot encrypted might have to be revealed, exposing any manipulation that may have occurred after submission; the system can't assume its actions will remain hidden. Individual voters can obtain as much confidence as they desire by challenging as many ballots as they wish. Although they won't ever be shown that the encryption of a cast ballot matches their selections, voters can see that every challenged ballot was correctly encrypted and committed to before the decision to cast or challenge was made. The ability to observe that all challenge ballots are correct thereby provides indirect evidence that cast ballots were also correct.","title":"Challenging a ballot"},{"location":"concepts/Verifiability/#publishing-verifiable-results","text":"When the election is complete and the results tallied, E2E-V elections publish the results so they can be verified independently. E2E-V election verifiers are written by third parties according to their interpretation of the ElectionGuard Specification . Any data published by an election should enable each and every cast encrypted ballot to be interrogated and tallied independently. From the spec: An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). Two things must be proven about the encryption of each vote: The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in a contest is equal to the selection limit for that contest (usually one). ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. Chaum-Pedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013 particularly that a value is an encryption of either zero or one. The set of encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit, again using a Chaum-Pedersen proof. Once every ballot is proven to be properly formed (as above), all of the votes for each option are homomorphically summed to produce encryptions of the tallies for each option. The final step is then to decrypt these tallies and provide additional proofs that the decryption are correct.","title":"Publishing Verifiable results"},{"location":"concepts/Verifiability/#showing-verification-code-results-to-voters","text":"In addition to satisfying the data requirements for proper verification, any publishing exercise needs to also enable individual voters to query for the ballot that matches their verification code. Verification code results of cast ballots will indicate that the ballot was included in the final tally, and any associated metadata about the device that recorded the ballot (time, location, election, etc.; see example above). Challenge ballots are also published. Results for verification codes of challenge ballots should indicate that the ballot was not included in the election tally. Because the ballot is not included in the election tally, the contents can be decrypted and presented as well.","title":"Showing Verification Code Results to Voters"},{"location":"concepts/Verifier/","text":"","title":"Verifier"},{"location":"concepts/Voter_Verification/","text":"","title":"Voter"},{"location":"contribute/","text":"Contribute Whenever possible and as a guiding principle, the evolution of the ElectionGuard SDK will be driven by the use cases and priorities of the community and in service of best-practice implementations of real-world, secret-ballot public elections. Community contributions are highly valued. Help defend democracy and contribute to ElectionGuard. Where to Start? There are many locations to contribute to ElectionGuard. ElectionGuard is an open source platform and depends on an active community and ecosystem. The SDK is comprised of five repositories: ElectionGuard Specification ElectionGuard Python ElectionGuard C++ ElectionGuard Python API ElectionGuard React UI Ways to get involved Learn about ElectionGuard and share the information Post questions or ideas in our discussion board Join our weekly video office hours Develop on issues in the repos with tags of good first issue or help wanted Add to and improve documentation. Keep it Plain English and include helpful images . Contributions ElectionGuard relies on its community for its success. For example, for end-to-end verifiable elections, integrity is improved by the number of independent verifiers that confirm the results of an election. Verifiers Python Verifier by Rainbow Huang C# Verifier by Brandon Alexander Java Verifier by John Caron Python Verifier (electionguard-verify) by Nicholas Boucher Library Ports Java port of Python Library by John Caron","title":"Contribute"},{"location":"contribute/#contribute","text":"Whenever possible and as a guiding principle, the evolution of the ElectionGuard SDK will be driven by the use cases and priorities of the community and in service of best-practice implementations of real-world, secret-ballot public elections. Community contributions are highly valued. Help defend democracy and contribute to ElectionGuard.","title":"Contribute"},{"location":"contribute/#where-to-start","text":"There are many locations to contribute to ElectionGuard. ElectionGuard is an open source platform and depends on an active community and ecosystem. The SDK is comprised of five repositories: ElectionGuard Specification ElectionGuard Python ElectionGuard C++ ElectionGuard Python API ElectionGuard React UI","title":"Where to Start?"},{"location":"contribute/#ways-to-get-involved","text":"Learn about ElectionGuard and share the information Post questions or ideas in our discussion board Join our weekly video office hours Develop on issues in the repos with tags of good first issue or help wanted Add to and improve documentation. Keep it Plain English and include helpful images .","title":"Ways to get involved"},{"location":"contribute/#contributions","text":"ElectionGuard relies on its community for its success. For example, for end-to-end verifiable elections, integrity is improved by the number of independent verifiers that confirm the results of an election.","title":"Contributions"},{"location":"contribute/#verifiers","text":"Python Verifier by Rainbow Huang C# Verifier by Brandon Alexander Java Verifier by John Caron Python Verifier (electionguard-verify) by Nicholas Boucher","title":"Verifiers"},{"location":"contribute/#library-ports","text":"Java port of Python Library by John Caron","title":"Library Ports"},{"location":"develop/Getting_Started/","text":"Getting Started If you're looking to develop for ElectionGuard, it might help if you pick something you're familiar with. The following repositories showcase the language to assist you in finding the right place. Each repository contains information on the best way to contribute and how to setup the development environment. Take a look and see what appeals to you. ElectionGuard Specification The ElectionGuard Specification repo addresses the mathematical and conceptual underpinnings of end-to-end verifiability in a manner that comfortably accommodates post-election audits. The specification houses the core data constructs, tests, and datasets that we recommend to ensure portability and data integrity. The ElectionGuard site is also built from this repository using mkdocs. This can be a friendly place to start out for new developers trying to get started. ElectionGuard Specification ElectionGuard Python The ElectionGuard Python library is the reference implementation of the ElectionGuard SDK. It covers the entire suite of functionality and processes necessary to implement an end-to-end verifiable election as part a voting system: Key generation ceremony Ballot encryption Tally ceremony Ballot decryption It is designed to be portable over performant , universal over Pythonic (although we do try to adhere to the Zen of Python ). Any real-world voting use case will need to incorporate the capabilities of the Python library to run an end-to-end verifiable election or post-election audit . Source | Package | Documentation Community-sourced Java port Check out our community contributions for a java port . ElectionGuard C++ The ElectionGuard C++ library performs ballot encryption. It is designed for devices that handle the user experience of voting. These devices follow the economics and performance of embedded systems: special-purpose devices designed for low cost. We assume Intel Atom class processor-level performance and Raspberry Pi 3 types of operating systems. In addition to the C++ library itself, there is some focus on target different standalone packages. This leads to the usage of other languages like C and C#. Source","title":"Getting Started"},{"location":"develop/Getting_Started/#getting-started","text":"If you're looking to develop for ElectionGuard, it might help if you pick something you're familiar with. The following repositories showcase the language to assist you in finding the right place. Each repository contains information on the best way to contribute and how to setup the development environment. Take a look and see what appeals to you.","title":"Getting Started"},{"location":"develop/Getting_Started/#electionguard-specification","text":"The ElectionGuard Specification repo addresses the mathematical and conceptual underpinnings of end-to-end verifiability in a manner that comfortably accommodates post-election audits. The specification houses the core data constructs, tests, and datasets that we recommend to ensure portability and data integrity. The ElectionGuard site is also built from this repository using mkdocs. This can be a friendly place to start out for new developers trying to get started. ElectionGuard Specification","title":"ElectionGuard Specification  "},{"location":"develop/Getting_Started/#electionguard-python","text":"The ElectionGuard Python library is the reference implementation of the ElectionGuard SDK. It covers the entire suite of functionality and processes necessary to implement an end-to-end verifiable election as part a voting system: Key generation ceremony Ballot encryption Tally ceremony Ballot decryption It is designed to be portable over performant , universal over Pythonic (although we do try to adhere to the Zen of Python ). Any real-world voting use case will need to incorporate the capabilities of the Python library to run an end-to-end verifiable election or post-election audit . Source | Package | Documentation Community-sourced Java port Check out our community contributions for a java port .","title":"ElectionGuard Python  "},{"location":"develop/Getting_Started/#electionguard-c","text":"The ElectionGuard C++ library performs ballot encryption. It is designed for devices that handle the user experience of voting. These devices follow the economics and performance of embedded systems: special-purpose devices designed for low cost. We assume Intel Atom class processor-level performance and Raspberry Pi 3 types of operating systems. In addition to the C++ library itself, there is some focus on target different standalone packages. This leads to the usage of other languages like C and C#. Source","title":"ElectionGuard C++  "},{"location":"develop/Repositories/","text":"Repositories The SDK is comprised of five repositories: ElectionGuard Specification ElectionGuard Python ElectionGuard C++ ElectionGuard Python API ElectionGuard React UI Diagrams flowchart TD subgraph \"Repositories\" spec[\"electionguard\"] -.-> |python|e-python[\"electionguard-python\"]; spec[\"electionguard\"] -.-> |C++|e-cpp[\"electionguard-cpp\"]; pypi --> web-api[\"electionguard-api-python\"]; e-python --> |pypi|pypi[\"python module: electionguard\"]:::package; web-api --> e-ui[\"electionguard-ui\"]; e-cpp --> |nuget| nuget[\"ElectionGuard.Encryption\"]:::package; end subgraph \"Overview\" specification -.-> |python|python[\"core\"]; specification -.-> |C++|cpp[\"encryption\"]; python --> |pypi|module:::package module --> api[\"web-api\"]; api --> ui[\"user interface\"]; cpp --> |nuget|package:::package end classDef package fill: teal, stroke: black;","title":"Repositories"},{"location":"develop/Repositories/#repositories","text":"The SDK is comprised of five repositories: ElectionGuard Specification ElectionGuard Python ElectionGuard C++ ElectionGuard Python API ElectionGuard React UI","title":"Repositories"},{"location":"develop/Repositories/#diagrams","text":"flowchart TD subgraph \"Repositories\" spec[\"electionguard\"] -.-> |python|e-python[\"electionguard-python\"]; spec[\"electionguard\"] -.-> |C++|e-cpp[\"electionguard-cpp\"]; pypi --> web-api[\"electionguard-api-python\"]; e-python --> |pypi|pypi[\"python module: electionguard\"]:::package; web-api --> e-ui[\"electionguard-ui\"]; e-cpp --> |nuget| nuget[\"ElectionGuard.Encryption\"]:::package; end subgraph \"Overview\" specification -.-> |python|python[\"core\"]; specification -.-> |C++|cpp[\"encryption\"]; python --> |pypi|module:::package module --> api[\"web-api\"]; api --> ui[\"user interface\"]; cpp --> |nuget|package:::package end classDef package fill: teal, stroke: black;","title":"Diagrams"},{"location":"develop/Sample_Data/","text":"Sample Data To better understand the data formats used by ElectionGuard, sample data is provided here to guide new developers. Four Sample Elections We have provided sample data for four different elections: Minimal - This is the most minimal election manifest file possible, designed to be easy to inspect and quick to develop against for rapid testing. All optional fields have been removed from the election manifest file. The election contains a single Yes/No referendum with a single ballot style in a single geopolitical unit. Small - This is designed to be a relatively small and simple election, but with more complexity than the minimal election. This is a good sample data set to begin understanding more complex ballot types with two or more geopolitical units or ballot styles. Three contests are listed (one of each type: Yes/No Referendum, Select One, and Select n of m), two GP units, two ballot styles, and a small number of recommended optional fields are included. Full - This is a more realistic example for a primary election for a municipality. This ballot contains several geopolitical units with multiple ballot styles and contains all optional metadata fields. This sample has multi-language support and multiple submitted ballot samples. Hamilton General - This is a complete example for a general election for a fictional municipality. This example contains many geopolitical units with multiple ballot styles and demonstrates how political districts overlap. This sample has multi-language support and multiple submitted ballot samples. The Hamilton General example also includes the election private data that includes guardian private keys. More information about the Hamilton General Example can be found in the Election Manifest Documentation . Data Election Manifests The Election Manifest contains all the details of the election (such as contests, candidates, selections, ballot styles, etc.) and is required at the start of an ElectionGuard election. Manifest Examples: minimal | small | full | hamilton Submitted Ballots Submitted Ballots are encrypted ballots that have been cast or spoiled. Cast ballots will be tallied and spoiled ballots are decrypted. Submitted Ballot Examples: minimal | small | full | hamilton Election Record The Election Record are the files required at the end of the election to verify the election and are intended to be posted publicly. There should not be any sensitive data (eg: no guardian private keys) in the record. These include the following: Manifest Election Context Election Constants Encrypted Tally Decrypted Tally Guardian Records Encryption Device Information Encrypted Ballots Decrypted Spoiled Ballots Example Folder Structure: \ud83d\udcc2 artifacts --- \ud83d\udcc4 manifest.json --- \ud83d\udcc4 context.json --- \ud83d\udcc4 constants.json --- \ud83d\udcc4 encrypted_tally.json --- \ud83d\udcc4 tally.json --- \ud83d\udcc1 guardians --- \ud83d\udcc1 devices --- \ud83d\udcc1 encrypted_ballots --- \ud83d\udcc1 spoiled_ballots Artifacts Examples: minimal | small | full | hamilton","title":"Sample Data"},{"location":"develop/Sample_Data/#sample-data","text":"To better understand the data formats used by ElectionGuard, sample data is provided here to guide new developers.","title":"Sample Data"},{"location":"develop/Sample_Data/#four-sample-elections","text":"We have provided sample data for four different elections: Minimal - This is the most minimal election manifest file possible, designed to be easy to inspect and quick to develop against for rapid testing. All optional fields have been removed from the election manifest file. The election contains a single Yes/No referendum with a single ballot style in a single geopolitical unit. Small - This is designed to be a relatively small and simple election, but with more complexity than the minimal election. This is a good sample data set to begin understanding more complex ballot types with two or more geopolitical units or ballot styles. Three contests are listed (one of each type: Yes/No Referendum, Select One, and Select n of m), two GP units, two ballot styles, and a small number of recommended optional fields are included. Full - This is a more realistic example for a primary election for a municipality. This ballot contains several geopolitical units with multiple ballot styles and contains all optional metadata fields. This sample has multi-language support and multiple submitted ballot samples. Hamilton General - This is a complete example for a general election for a fictional municipality. This example contains many geopolitical units with multiple ballot styles and demonstrates how political districts overlap. This sample has multi-language support and multiple submitted ballot samples. The Hamilton General example also includes the election private data that includes guardian private keys. More information about the Hamilton General Example can be found in the Election Manifest Documentation .","title":"Four Sample Elections"},{"location":"develop/Sample_Data/#data","text":"","title":"Data"},{"location":"develop/Sample_Data/#election-manifests","text":"The Election Manifest contains all the details of the election (such as contests, candidates, selections, ballot styles, etc.) and is required at the start of an ElectionGuard election. Manifest Examples: minimal | small | full | hamilton","title":"Election Manifests"},{"location":"develop/Sample_Data/#submitted-ballots","text":"Submitted Ballots are encrypted ballots that have been cast or spoiled. Cast ballots will be tallied and spoiled ballots are decrypted. Submitted Ballot Examples: minimal | small | full | hamilton","title":"Submitted Ballots"},{"location":"develop/Sample_Data/#election-record","text":"The Election Record are the files required at the end of the election to verify the election and are intended to be posted publicly. There should not be any sensitive data (eg: no guardian private keys) in the record. These include the following: Manifest Election Context Election Constants Encrypted Tally Decrypted Tally Guardian Records Encryption Device Information Encrypted Ballots Decrypted Spoiled Ballots Example Folder Structure: \ud83d\udcc2 artifacts --- \ud83d\udcc4 manifest.json --- \ud83d\udcc4 context.json --- \ud83d\udcc4 constants.json --- \ud83d\udcc4 encrypted_tally.json --- \ud83d\udcc4 tally.json --- \ud83d\udcc1 guardians --- \ud83d\udcc1 devices --- \ud83d\udcc1 encrypted_ballots --- \ud83d\udcc1 spoiled_ballots Artifacts Examples: minimal | small | full | hamilton","title":"Election Record"},{"location":"overview/Features/","text":"Features Work in Progress This is a work in progress. Feel free to contribute.","title":"Features"},{"location":"overview/Features/#features","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Features"},{"location":"overview/Glossary/","text":"ElectionGuard Glossary Overview Software development kits (SDKs) such as ElectionGuard, by their very nature, are intended to stitch together multiple distinct actions or areas into a cohesive whole. By necessity an SDK must \"speak\" multiple languages so the different actors involved can understand how the SDK fits in their world. This Glossary attempts to address its different audiences with terms and constructs appropriate to each: for election administrators, terms that map to their conception of the voting process and user experience; for developers, efficient constructs and a grammar that conveys the appropriate action to be performed and the proper state of the entity they're working with; for cryptographers and verifier contributors, consistency of usage between the specification and code, and sufficiently clear descriptions of the techniques and terms necessary for proper treatment and interpretation of the election record and all processes; and for everyone, clear articulation of the meaning and rationale for the different facets of end-to-end verifiability To illustrate what that means in practice, take one of the fundamental tenets of end-to-end verifiability: spoiling , challenging , or decrypting a ballot. Each of these words can mean the same thing sometimes but not always; it depends on the context of the usage. So in this example: Spoiling a ballot is a process election administrators use to allow voters who make mistakes filling out a ballot to begin again with a replacement ballot; in this context, the spoil process is a physical process undertaken by poll workers to ensure the ballot with a mistake is not included in any tallies. Challenging a ballot is the process voters use to challenge the integrity of the voting system by forcing it to reveal what it would have submitted if the ballot were actually cast; challenged ballots are published in their unencrypted (original, human-readable) state Decrypting a ballot is the process developers use to reveal a ballot's unencrypted contents; election guardians decrypt challenge ballots as part of the publishing process for end-to-end-verifiable elections . Info Whenever possible, we used terms and meanings consistent the NIST Elections Guide . Terms accepted ballot A ballot that is accepted for inclusion in election results and is either: cast or spoiled. auxiliary key pair Pair of keys (public & secret) used to encrypt/decrypt information sent between guardians. Auxiliary key pairs are used available guardian A guardian that has announced as present for the decryption phase ballot box A collection of ballots that have been either cast or spoiled. ballot chain ballot encryption (see encrypting a ballot ) ballot lifecycle base hash \\(Q\\) Represented as \\(Q\\) , the base hash is the hash of the election cast ballot A ballot which a voter has accepted as valid to be included in the official election tally. challenge ballot ciphertext ballot An encrypted representation of a voter's filled-in ballot. ciphertext election context The cryptographic context of an election that is configured during the Key Ceremony code (see verification code ) Info Code has many meanings. Code can refer to the Python and C++ repos. Code can also mean code the noun (\"I'm going to look at the code\") and verb (\"I'm going to go code\") generally. Context matters Code in the ElectionGuard context refers to the verification code generated by the ballot encryption process. That is code in the code libraries themselves is the hexadecimal string generated by the ballot encryption process. compact ballot compensated decryption share A partial decryption share value computed by an available guardian to compensate for a missing guardian so that the missing guardian's share can be generated and the election results can be successfully decrypted. contest A contest in an election consists of a set of options together with a selection limit that indicates the number of selections that are allowed to be made in that contest. In most elections, most contests have a selection limit of one. However, a larger selection limit (e.g., select up to three) is not uncommon in some elections. Approval voting can be achieved by setting the selection limit to the total number of options in a contest. Ranked choice voting is not supported in this version of ElectionGuard, but it may be enabled in a future version.2 Also, write-ins are assumed to be explicitly registered or allowed to be lumped into a single \"write-ins\" category for the purpose of verifiable tallying. Verifiable tallying of free-form write-ins may be best done with a MixNet3 design. A legitimate vote in a contest consists of a set of selections with cardinality not exceeding the selection limit of that contest. To accommodate legitimate undervotes, the internal representation of a contest is augmented with \u201cplaceholder\u201d options equal in number to the selection limit. Placeholder options are selected as necessary to force the total number of selections made in a contest to be equal to the selection limit. When the selection limit is one, for example, the single placeholder option can be thought of as a \u201cnone of the above\u201d option. With larger selection limits, the number of placeholder options selected corresponds to the number of additional options that a voter could have selected in a contest. decrypting a ballot A graph LR a1(ciphertext ballot) -->|decrypt| a2(plaintext ballot) decrypting a tally graph LR a1(ciphertext tally) -->|decrypt| a2(plaintext tally) decryption mediator A component or actor responsible for composing each guardian's partial decryptions or compensated decryptions into the plaintext tally decryption share A guardian's partial share of a decryption description hash ( preferred: base hash ) A hash representation of the original election description election election description The election description is the election metadata that describes the structure and type of the election, including geopolitical units, contests, candidates, ballot styles, etc. A subset of this data, the manifest is encrypted with the joint public key generated by the key ceremony conducted by the election guardians to generate the extended base hash that will be used to uniquely associate an encrypted ballot with a specific election. election guardian One of a number of independent, trustworthy individuals who as part of serving as an election guardian in an end-to-end verifiable election participate in a key ceremony to create a joint public election key and perform a tally election manifest (see manifest ) election partial key backup A point on a secret polynomial and commitments to verify this point for a designated guardian. election polynomial The election polynomial is the mathematical expression that each Guardian defines to solve for his or her private key. A different point associated with the polynomial is shared with each of the other guardians so that the guardians can come together to derive the polynomial function and solve for the private key. encrypt encrypted ballot metadata A specific subset of election metadata encrypted tally The homomorphically-combined and encrypted representation of all selections made for each option on every contest in the election. encrypting a ballot As outlined in the ElectionGuard Specification graph LR a1(plaintext ballot) -->|encrypt| a2(cipertext ballot) graph LR a1(plaintext ballot) -->|encrypt| a2(cipertext ballot) encryption device The device that is doing the encryption end-to-end-verifiable election An election is end-to-end verifiable 1 if: Cast as intended -- voters can verify that their own selections have been correctly recorded. Counted as cast -- anyone can verify that the recorded votes have been correctly tallied. extended base hash \\(\\overline{Q}\\) graph LR A[joint public key] --> C>extended base hash]; B[manifest] --> C; guardian (see election guardian ) hardware security module (hsm) hash Hashing is a common practice in computing; ElectionGuard uses hashing in its cryptographic context , a mechanism to map data of an arbitrary size into a fixed-size equivalent. This is done for a variety of reasons, including preventing discovery of election ballot contents. internal election description Deprecated this term is deprecated and replaced with manifest The subset of the election description required by ElectionGuard and combined with the joint public key to create the extended base hash used at the instantiation of the encrypted ballot ballot chain ballots are correctly associated with an election. This component mutates the state of the Election Description. joint public key Combined public key generated by the key ceremony of the election guardians. Each election guardian creates their own public-private key pair and shares the public key with the other guardians. The output of the ceremony is the joint public key used by voting devices to encrypt ballots . graph LR a2 & b2 & c2 --> jk1[key ceremony] --> jk2(joint public key) subgraph eg1[election guardian 1] a1(private key) -.- a2(public key) end subgraph eg2[election guardian 2] b1(private key) -.- b2(public key) end subgraph eg3[election guardian n] c1(private key) -.- c2(public key) end Creating a joint public key as part of the key ceremony key ceremony The process conducted at the beginning of the election to create the joint encryption context for encrypting ballots during the election. key ceremony mediator A mediator to mediate communication (if needed) of information such as keys between the guardians key pair A key pair consists of a linked private key and public key . Key pairs are used in public key cryptography , in which public keys are distributed to others to encrypt messages that only the private key can decrypt . In ElectionGuard, each election guardian that is part of an election creates a public-private key pair and shares their private key with the other election guardians as part of the key ceremony graph LR subgraph kp[key pair] a1(private key) -.- a2(public key) end manifest The manifest is a subset of the election description that uniquely specifies an election. It is combined with the joint public key to create the extended base hash used to instantiate a voting device to encrypt ballots master nonce A mediator to mediate communication (if needed) of information such as keys between the guardians missing guardian A guardian who was configured during the Key Ceremony but who is not present for the decryption of the election results. nonce A random number used to derive encryptions NIZK (see non-interactive-zero-knowledge proof ) non-interactive-zero-knowledge proof A zero-knowledge proof is a method by which one party (the prover) can prove to another party (the verifier) that they know a value \\(x\\) , without conveying any information apart from the fact that they know the value \\(x\\) . The essence of zero-knowledge proofs is that it is trivial to prove that one possesses knowledge of certain information by simply revealing it; the challenge is to prove such possession without revealing the information itself or any additional information. 2 A non-interactive-zero-knowledge proof (NIZK) is a zero-knowledge proof that can be performed without interaction or intervention by the prover. ElectionGuard uses four different types of NIZK to enable ElectionGuard to demonstrate: keys are properly chosen ballots are properly formed decryptions match claimed values plaintext ballot The plaintext representation of a voter's selections post-election audit A post-election audit is \\(Q\\) --see Base hash The base hash is the hash of the election manifest metadata \\(\\overline{Q}\\) --see Extended base hash quorum The minimum count ( threshold ) of guardians that must be present in order to successfully decrypt the election results. spoiled ballot A spoiled ballot is an election term that refers to a ballot that, typically due to a mistake, allows a voter to turn in their ballot and instead submit a replacement ballot as their official cast ballot . In this context, spoiling is the process election administrators use to make sure this ballot is not included in the election tally. Ballot spoiling is used in end-to-end verifiability as a means for voters to challenge the voting machine and force it to reveal the contents of spoiled ballots for public scrutiny. Because the ballot will not be used in the official tally, its contents can be revealed. And because the spoil process happens after ballot encryption, the machine cannot modify the encrypted ballot retrospectively without revealing its attempt. submitted ballot A submitted ballot is an encrypted ballot that has been cast or spoiled graph LR a1(encrypted ballot) -->|cast| a2(submitted ballot) a1 --> |spoiled| a2 tally ceremony undervote An undervote in a contest or election unknown ballot An unknown ballot is a submitted ballot which has not been determined to be cast or spoiled , or that may have been spoiled but is otherwise not published in the election results. verification code A unique hash value generated by an Encryption Device to anonymously identify a ballot See also End-to-end Verifiability \u21a9 From Wikipedia ( Zero-Knowledge Proof \u21a9","title":"Glossary"},{"location":"overview/Glossary/#electionguard-glossary","text":"","title":"ElectionGuard Glossary"},{"location":"overview/Glossary/#overview","text":"Software development kits (SDKs) such as ElectionGuard, by their very nature, are intended to stitch together multiple distinct actions or areas into a cohesive whole. By necessity an SDK must \"speak\" multiple languages so the different actors involved can understand how the SDK fits in their world. This Glossary attempts to address its different audiences with terms and constructs appropriate to each: for election administrators, terms that map to their conception of the voting process and user experience; for developers, efficient constructs and a grammar that conveys the appropriate action to be performed and the proper state of the entity they're working with; for cryptographers and verifier contributors, consistency of usage between the specification and code, and sufficiently clear descriptions of the techniques and terms necessary for proper treatment and interpretation of the election record and all processes; and for everyone, clear articulation of the meaning and rationale for the different facets of end-to-end verifiability To illustrate what that means in practice, take one of the fundamental tenets of end-to-end verifiability: spoiling , challenging , or decrypting a ballot. Each of these words can mean the same thing sometimes but not always; it depends on the context of the usage. So in this example: Spoiling a ballot is a process election administrators use to allow voters who make mistakes filling out a ballot to begin again with a replacement ballot; in this context, the spoil process is a physical process undertaken by poll workers to ensure the ballot with a mistake is not included in any tallies. Challenging a ballot is the process voters use to challenge the integrity of the voting system by forcing it to reveal what it would have submitted if the ballot were actually cast; challenged ballots are published in their unencrypted (original, human-readable) state Decrypting a ballot is the process developers use to reveal a ballot's unencrypted contents; election guardians decrypt challenge ballots as part of the publishing process for end-to-end-verifiable elections . Info Whenever possible, we used terms and meanings consistent the NIST Elections Guide .","title":"Overview"},{"location":"overview/Glossary/#terms","text":"","title":"Terms"},{"location":"overview/Glossary/#accepted-ballot","text":"A ballot that is accepted for inclusion in election results and is either: cast or spoiled.","title":"accepted ballot"},{"location":"overview/Glossary/#auxiliary-key-pair","text":"Pair of keys (public & secret) used to encrypt/decrypt information sent between guardians. Auxiliary key pairs are used","title":"auxiliary key pair"},{"location":"overview/Glossary/#available-guardian","text":"A guardian that has announced as present for the decryption phase","title":"available guardian"},{"location":"overview/Glossary/#ballot-box","text":"A collection of ballots that have been either cast or spoiled.","title":"ballot box"},{"location":"overview/Glossary/#ballot-chain","text":"","title":"ballot chain"},{"location":"overview/Glossary/#ballot-encryption-see-encrypting-a-ballot","text":"","title":"ballot encryption (see encrypting a ballot )"},{"location":"overview/Glossary/#ballot-lifecycle","text":"","title":"ballot lifecycle"},{"location":"overview/Glossary/#base-hash-q","text":"Represented as \\(Q\\) , the base hash is the hash of the election","title":"base hash \\(Q\\)"},{"location":"overview/Glossary/#cast-ballot","text":"A ballot which a voter has accepted as valid to be included in the official election tally.","title":"cast ballot"},{"location":"overview/Glossary/#challenge-ballot","text":"","title":"challenge ballot"},{"location":"overview/Glossary/#ciphertext-ballot","text":"An encrypted representation of a voter's filled-in ballot.","title":"ciphertext ballot"},{"location":"overview/Glossary/#ciphertext-election-context","text":"The cryptographic context of an election that is configured during the Key Ceremony","title":"ciphertext election context"},{"location":"overview/Glossary/#code-see-verification-code","text":"Info Code has many meanings. Code can refer to the Python and C++ repos. Code can also mean code the noun (\"I'm going to look at the code\") and verb (\"I'm going to go code\") generally. Context matters Code in the ElectionGuard context refers to the verification code generated by the ballot encryption process. That is code in the code libraries themselves is the hexadecimal string generated by the ballot encryption process.","title":"code (see verification code)"},{"location":"overview/Glossary/#compact-ballot","text":"","title":"compact ballot"},{"location":"overview/Glossary/#compensated-decryption-share","text":"A partial decryption share value computed by an available guardian to compensate for a missing guardian so that the missing guardian's share can be generated and the election results can be successfully decrypted.","title":"compensated decryption share"},{"location":"overview/Glossary/#contest","text":"A contest in an election consists of a set of options together with a selection limit that indicates the number of selections that are allowed to be made in that contest. In most elections, most contests have a selection limit of one. However, a larger selection limit (e.g., select up to three) is not uncommon in some elections. Approval voting can be achieved by setting the selection limit to the total number of options in a contest. Ranked choice voting is not supported in this version of ElectionGuard, but it may be enabled in a future version.2 Also, write-ins are assumed to be explicitly registered or allowed to be lumped into a single \"write-ins\" category for the purpose of verifiable tallying. Verifiable tallying of free-form write-ins may be best done with a MixNet3 design. A legitimate vote in a contest consists of a set of selections with cardinality not exceeding the selection limit of that contest. To accommodate legitimate undervotes, the internal representation of a contest is augmented with \u201cplaceholder\u201d options equal in number to the selection limit. Placeholder options are selected as necessary to force the total number of selections made in a contest to be equal to the selection limit. When the selection limit is one, for example, the single placeholder option can be thought of as a \u201cnone of the above\u201d option. With larger selection limits, the number of placeholder options selected corresponds to the number of additional options that a voter could have selected in a contest.","title":"contest"},{"location":"overview/Glossary/#decrypting-a-ballot","text":"A graph LR a1(ciphertext ballot) -->|decrypt| a2(plaintext ballot)","title":"decrypting a ballot"},{"location":"overview/Glossary/#decrypting-a-tally","text":"graph LR a1(ciphertext tally) -->|decrypt| a2(plaintext tally)","title":"decrypting a tally"},{"location":"overview/Glossary/#decryption-mediator","text":"A component or actor responsible for composing each guardian's partial decryptions or compensated decryptions into the plaintext tally","title":"decryption mediator"},{"location":"overview/Glossary/#decryption-share","text":"A guardian's partial share of a decryption","title":"decryption share"},{"location":"overview/Glossary/#description-hash-preferred-base-hash","text":"A hash representation of the original election description","title":"description hash (preferred: base hash)"},{"location":"overview/Glossary/#election","text":"","title":"election"},{"location":"overview/Glossary/#election-description","text":"The election description is the election metadata that describes the structure and type of the election, including geopolitical units, contests, candidates, ballot styles, etc. A subset of this data, the manifest is encrypted with the joint public key generated by the key ceremony conducted by the election guardians to generate the extended base hash that will be used to uniquely associate an encrypted ballot with a specific election.","title":"election description"},{"location":"overview/Glossary/#election-guardian","text":"One of a number of independent, trustworthy individuals who as part of serving as an election guardian in an end-to-end verifiable election participate in a key ceremony to create a joint public election key and perform a tally","title":"election guardian"},{"location":"overview/Glossary/#election-manifest-see-manifest","text":"","title":"election manifest (see manifest)"},{"location":"overview/Glossary/#election-partial-key-backup","text":"A point on a secret polynomial and commitments to verify this point for a designated guardian.","title":"election partial key backup"},{"location":"overview/Glossary/#election-polynomial","text":"The election polynomial is the mathematical expression that each Guardian defines to solve for his or her private key. A different point associated with the polynomial is shared with each of the other guardians so that the guardians can come together to derive the polynomial function and solve for the private key.","title":"election polynomial"},{"location":"overview/Glossary/#encrypt","text":"","title":"encrypt"},{"location":"overview/Glossary/#encrypted-ballot-metadata","text":"A specific subset of election metadata","title":"encrypted ballot metadata"},{"location":"overview/Glossary/#encrypted-tally","text":"The homomorphically-combined and encrypted representation of all selections made for each option on every contest in the election.","title":"encrypted tally"},{"location":"overview/Glossary/#encrypting-a-ballot","text":"As outlined in the ElectionGuard Specification graph LR a1(plaintext ballot) -->|encrypt| a2(cipertext ballot) graph LR a1(plaintext ballot) -->|encrypt| a2(cipertext ballot)","title":"encrypting a ballot"},{"location":"overview/Glossary/#encryption-device","text":"The device that is doing the encryption","title":"encryption device"},{"location":"overview/Glossary/#end-to-end-verifiable-election","text":"An election is end-to-end verifiable 1 if: Cast as intended -- voters can verify that their own selections have been correctly recorded. Counted as cast -- anyone can verify that the recorded votes have been correctly tallied.","title":"end-to-end-verifiable election"},{"location":"overview/Glossary/#extended-base-hash-overlineq","text":"graph LR A[joint public key] --> C>extended base hash]; B[manifest] --> C;","title":"extended base hash \\(\\overline{Q}\\)"},{"location":"overview/Glossary/#guardian-see-election-guardian","text":"","title":"guardian (see election guardian)"},{"location":"overview/Glossary/#hardware-security-module-hsm","text":"","title":"hardware security module (hsm)"},{"location":"overview/Glossary/#hash","text":"Hashing is a common practice in computing; ElectionGuard uses hashing in its cryptographic context , a mechanism to map data of an arbitrary size into a fixed-size equivalent. This is done for a variety of reasons, including preventing discovery of election ballot contents.","title":"hash"},{"location":"overview/Glossary/#internal-election-description","text":"Deprecated this term is deprecated and replaced with manifest The subset of the election description required by ElectionGuard and combined with the joint public key to create the extended base hash used at the instantiation of the encrypted ballot ballot chain ballots are correctly associated with an election. This component mutates the state of the Election Description.","title":"internal election description"},{"location":"overview/Glossary/#joint-public-key","text":"Combined public key generated by the key ceremony of the election guardians. Each election guardian creates their own public-private key pair and shares the public key with the other guardians. The output of the ceremony is the joint public key used by voting devices to encrypt ballots . graph LR a2 & b2 & c2 --> jk1[key ceremony] --> jk2(joint public key) subgraph eg1[election guardian 1] a1(private key) -.- a2(public key) end subgraph eg2[election guardian 2] b1(private key) -.- b2(public key) end subgraph eg3[election guardian n] c1(private key) -.- c2(public key) end Creating a joint public key as part of the key ceremony","title":"joint public key"},{"location":"overview/Glossary/#key-ceremony","text":"The process conducted at the beginning of the election to create the joint encryption context for encrypting ballots during the election.","title":"key ceremony"},{"location":"overview/Glossary/#key-ceremony-mediator","text":"A mediator to mediate communication (if needed) of information such as keys between the guardians","title":"key ceremony mediator"},{"location":"overview/Glossary/#key-pair","text":"A key pair consists of a linked private key and public key . Key pairs are used in public key cryptography , in which public keys are distributed to others to encrypt messages that only the private key can decrypt . In ElectionGuard, each election guardian that is part of an election creates a public-private key pair and shares their private key with the other election guardians as part of the key ceremony graph LR subgraph kp[key pair] a1(private key) -.- a2(public key) end","title":"key pair"},{"location":"overview/Glossary/#manifest","text":"The manifest is a subset of the election description that uniquely specifies an election. It is combined with the joint public key to create the extended base hash used to instantiate a voting device to encrypt ballots","title":"manifest"},{"location":"overview/Glossary/#master-nonce","text":"A mediator to mediate communication (if needed) of information such as keys between the guardians","title":"master nonce"},{"location":"overview/Glossary/#missing-guardian","text":"A guardian who was configured during the Key Ceremony but who is not present for the decryption of the election results.","title":"missing guardian"},{"location":"overview/Glossary/#nonce","text":"A random number used to derive encryptions","title":"nonce"},{"location":"overview/Glossary/#nizk-see-non-interactive-zero-knowledge-proof","text":"","title":"NIZK (see non-interactive-zero-knowledge proof)"},{"location":"overview/Glossary/#non-interactive-zero-knowledge-proof","text":"A zero-knowledge proof is a method by which one party (the prover) can prove to another party (the verifier) that they know a value \\(x\\) , without conveying any information apart from the fact that they know the value \\(x\\) . The essence of zero-knowledge proofs is that it is trivial to prove that one possesses knowledge of certain information by simply revealing it; the challenge is to prove such possession without revealing the information itself or any additional information. 2 A non-interactive-zero-knowledge proof (NIZK) is a zero-knowledge proof that can be performed without interaction or intervention by the prover. ElectionGuard uses four different types of NIZK to enable ElectionGuard to demonstrate: keys are properly chosen ballots are properly formed decryptions match claimed values","title":"non-interactive-zero-knowledge proof"},{"location":"overview/Glossary/#plaintext-ballot","text":"The plaintext representation of a voter's selections","title":"plaintext ballot"},{"location":"overview/Glossary/#post-election-audit","text":"A post-election audit is","title":"post-election audit"},{"location":"overview/Glossary/#q-see-base-hash","text":"The base hash is the hash of the election manifest metadata","title":"\\(Q\\) --see Base hash"},{"location":"overview/Glossary/#overlineq-see-extended-base-hash","text":"","title":"\\(\\overline{Q}\\) --see Extended base hash"},{"location":"overview/Glossary/#quorum","text":"The minimum count ( threshold ) of guardians that must be present in order to successfully decrypt the election results.","title":"quorum"},{"location":"overview/Glossary/#spoiled-ballot","text":"A spoiled ballot is an election term that refers to a ballot that, typically due to a mistake, allows a voter to turn in their ballot and instead submit a replacement ballot as their official cast ballot . In this context, spoiling is the process election administrators use to make sure this ballot is not included in the election tally. Ballot spoiling is used in end-to-end verifiability as a means for voters to challenge the voting machine and force it to reveal the contents of spoiled ballots for public scrutiny. Because the ballot will not be used in the official tally, its contents can be revealed. And because the spoil process happens after ballot encryption, the machine cannot modify the encrypted ballot retrospectively without revealing its attempt.","title":"spoiled ballot"},{"location":"overview/Glossary/#submitted-ballot","text":"A submitted ballot is an encrypted ballot that has been cast or spoiled graph LR a1(encrypted ballot) -->|cast| a2(submitted ballot) a1 --> |spoiled| a2","title":"submitted ballot"},{"location":"overview/Glossary/#tally-ceremony","text":"","title":"tally ceremony"},{"location":"overview/Glossary/#undervote","text":"An undervote in a contest or election","title":"undervote"},{"location":"overview/Glossary/#unknown-ballot","text":"An unknown ballot is a submitted ballot which has not been determined to be cast or spoiled , or that may have been spoiled but is otherwise not published in the election results.","title":"unknown ballot"},{"location":"overview/Glossary/#verification-code","text":"A unique hash value generated by an Encryption Device to anonymously identify a ballot See also End-to-end Verifiability \u21a9 From Wikipedia ( Zero-Knowledge Proof \u21a9","title":"verification code"},{"location":"overview/Principles/","text":"Principles Work in Progress This is a work in progress. Feel free to contribute.","title":"Principles"},{"location":"overview/Principles/#principles","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Principles"},{"location":"overview/Roadmap/","text":"ElectionGuard Roadmap 2021 Roadmap The 2021 roadmap takes the learnings from the different applications deployed in 2020 and rationalizes them into a practice to establish with the community in 2021. The goal is to grow a community of participants and contributors within which Microsoft takes part in and provides architectural and implementation guidance, but is fundamentally driven by the needs of the community in establishing the best ways to implement end-to-end verifiable elections and post-election audits. A big step toward this new vision occurred with the release of the electionguard-cpp ballot-encryption repo. The electionguard-python repo implements the full suite of ElectionGuard SDK functionality and the base electionguard specification and documentation repo provides the foundation for future development. The goal for the first half of 2021 is to have a full suite of code, tests, workflows, and package deployments more directly associated with the conventions and requirements indicated by the specification. The goal is also to publish and generate more comprehensive and also more granular examples and use cases to enable easier and more focused contributions by the community. 1.0 Specification a final, fully-developed specification integrated directly into the SDK; updates to election manifest and election artifact descriptions and specifications a more modular approach to documentation and contribution to lessen the learning curve and overhead necessary to participate and contribute more prescriptive guidance on verifier construction C++ ballot encryption library repo that performs encryption exclusively (for embedded encryption applications such as precinct scanners) standalone source that uses a version of HACL* packaged up by EverCrypt for high assurance (thank you EverCrypt team!) enables ElectionGuard to eliminate GMP as a dependency Release an ElectionGuard.Encryption nuget package built from electionguard-cpp as a ballot encrypter for low performance devices Establish publishing pattern First target will be Windows 10 / UWP A consistent, efficient set of data interfaces across the ElectionGuard, C++, and Python repos Data serialization using Protobuf for input/output/data consistency across electionguard-cpp and electionguard-python Restructuring ballot and device aggregation to better support audits and scalability in general Renaming and refactoring all repos for more descriptive and specific naming patterns Compose community changes into electionguard-python release v1.1.16 Optimization changes for service implementations of electionguard-python release v1.4.0 Introduce service docker containers in electionguard-api 2020 In Review 2020 taught many lessons. The first half of the year saw a successful Fulton, WI Election Pilot with VotingWorks and InfernoRed . Subsequent to the election the Python repo was released as a new reference implementation. In the second half of the year , responding to COVID led to the development of a remote voting app with InfernoRed , Markup , and the US House Democratic Caucus to enable representatives to vote by secret ballot safely, securely, and remotely for Caucus leadership positions . In a further collaborate with VotingWorks, Rice University professor Dan Wallach contributed an integration with Arlo to enable ElectionGuard to provide the \"back end\" for Inyo County's Risk-limiting Audit of the November 3 election . Last and definitely not least, the first independent verifiers were developed and published . 2020 Roadmap Use ElectionGuard in a real-world end-to-end verifiable election Run a verifiable election Fulton, Wisconsin with VotingWorks using smart cards, a ballot box, an admin device, and a ballot tracking site. Integrate ElectionGuard with the VotingWorks print station and user flow Build ballot box functionality to capture and seal ballots Build admin device to enable tallies and key ceremonies Build tracking site to enable verification code lookup and tally/results download Use ElectionGuard in a real-world post-election audit Run a post-election election audit with Inyo, California using VotingWorks Arlo using ElectionGuard as a back end Identify learnings and code refactoring necessary to reflect the different data structures and scalability considerations of audits Update the ElectionGuard specification to 0.95.0 Support building ElectionGuard into additional voting systems Enable remote, secret-ballot voting for Democratic Caucus of the US House of Representatives Work with InfernoRed and Markup to enable House-distributed iPhones to perform ballot encryption and House Democratic leadership to schedule and tally secret-ballot elections for leadership and committee positions Release and iterate on electionguard-python as a core implementation that meets specification 0.95.0 Implement a canonical library addressing all ElectionGuard SDK functionality: Key generation Ballot encryption Ballot sealing Tally generation Verifier specification Build library with an eye to extensibility rather than performance and local language optimization (i.e., we'll be less Pythonic than some might prefer for the base implementation) Integrate ElectionGuard into a set of election tools 2019 Roadmap Initial specification and electionguard-c release Demonstrate ElectionGuard Reference Implementation at Aspen Security Conference","title":"Roadmap"},{"location":"overview/Roadmap/#electionguard-roadmap","text":"","title":"ElectionGuard Roadmap"},{"location":"overview/Roadmap/#2021-roadmap","text":"The 2021 roadmap takes the learnings from the different applications deployed in 2020 and rationalizes them into a practice to establish with the community in 2021. The goal is to grow a community of participants and contributors within which Microsoft takes part in and provides architectural and implementation guidance, but is fundamentally driven by the needs of the community in establishing the best ways to implement end-to-end verifiable elections and post-election audits. A big step toward this new vision occurred with the release of the electionguard-cpp ballot-encryption repo. The electionguard-python repo implements the full suite of ElectionGuard SDK functionality and the base electionguard specification and documentation repo provides the foundation for future development. The goal for the first half of 2021 is to have a full suite of code, tests, workflows, and package deployments more directly associated with the conventions and requirements indicated by the specification. The goal is also to publish and generate more comprehensive and also more granular examples and use cases to enable easier and more focused contributions by the community. 1.0 Specification a final, fully-developed specification integrated directly into the SDK; updates to election manifest and election artifact descriptions and specifications a more modular approach to documentation and contribution to lessen the learning curve and overhead necessary to participate and contribute more prescriptive guidance on verifier construction C++ ballot encryption library repo that performs encryption exclusively (for embedded encryption applications such as precinct scanners) standalone source that uses a version of HACL* packaged up by EverCrypt for high assurance (thank you EverCrypt team!) enables ElectionGuard to eliminate GMP as a dependency Release an ElectionGuard.Encryption nuget package built from electionguard-cpp as a ballot encrypter for low performance devices Establish publishing pattern First target will be Windows 10 / UWP A consistent, efficient set of data interfaces across the ElectionGuard, C++, and Python repos Data serialization using Protobuf for input/output/data consistency across electionguard-cpp and electionguard-python Restructuring ballot and device aggregation to better support audits and scalability in general Renaming and refactoring all repos for more descriptive and specific naming patterns Compose community changes into electionguard-python release v1.1.16 Optimization changes for service implementations of electionguard-python release v1.4.0 Introduce service docker containers in electionguard-api","title":"2021 Roadmap"},{"location":"overview/Roadmap/#2020-in-review","text":"2020 taught many lessons. The first half of the year saw a successful Fulton, WI Election Pilot with VotingWorks and InfernoRed . Subsequent to the election the Python repo was released as a new reference implementation. In the second half of the year , responding to COVID led to the development of a remote voting app with InfernoRed , Markup , and the US House Democratic Caucus to enable representatives to vote by secret ballot safely, securely, and remotely for Caucus leadership positions . In a further collaborate with VotingWorks, Rice University professor Dan Wallach contributed an integration with Arlo to enable ElectionGuard to provide the \"back end\" for Inyo County's Risk-limiting Audit of the November 3 election . Last and definitely not least, the first independent verifiers were developed and published .","title":"2020 In Review"},{"location":"overview/Roadmap/#2020-roadmap","text":"Use ElectionGuard in a real-world end-to-end verifiable election Run a verifiable election Fulton, Wisconsin with VotingWorks using smart cards, a ballot box, an admin device, and a ballot tracking site. Integrate ElectionGuard with the VotingWorks print station and user flow Build ballot box functionality to capture and seal ballots Build admin device to enable tallies and key ceremonies Build tracking site to enable verification code lookup and tally/results download Use ElectionGuard in a real-world post-election audit Run a post-election election audit with Inyo, California using VotingWorks Arlo using ElectionGuard as a back end Identify learnings and code refactoring necessary to reflect the different data structures and scalability considerations of audits Update the ElectionGuard specification to 0.95.0 Support building ElectionGuard into additional voting systems Enable remote, secret-ballot voting for Democratic Caucus of the US House of Representatives Work with InfernoRed and Markup to enable House-distributed iPhones to perform ballot encryption and House Democratic leadership to schedule and tally secret-ballot elections for leadership and committee positions Release and iterate on electionguard-python as a core implementation that meets specification 0.95.0 Implement a canonical library addressing all ElectionGuard SDK functionality: Key generation Ballot encryption Ballot sealing Tally generation Verifier specification Build library with an eye to extensibility rather than performance and local language optimization (i.e., we'll be less Pythonic than some might prefer for the base implementation) Integrate ElectionGuard into a set of election tools","title":"2020 Roadmap"},{"location":"overview/Roadmap/#2019-roadmap","text":"Initial specification and electionguard-c release Demonstrate ElectionGuard Reference Implementation at Aspen Security Conference","title":"2019 Roadmap"},{"location":"spec/Badges/","text":"Badges For your convenience, these are some badges to add to your repository indicating the specification your code supports. [![ElectionGuard Specification 0.85.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard%20Specification-0.85.0-green)](https://www.electionguard.vote) [![ElectionGuard Specification 0.95.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard%20Specification-0.95.0-green)](https://www.electionguard.vote) [![ElectionGuard Specification 1.0.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard%20Specification-1.0.0-yellow)](https://www.electionguard.vote)","title":"Badges"},{"location":"spec/Badges/#badges","text":"For your convenience, these are some badges to add to your repository indicating the specification your code supports. [![ElectionGuard Specification 0.85.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard%20Specification-0.85.0-green)](https://www.electionguard.vote) [![ElectionGuard Specification 0.95.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard%20Specification-0.95.0-green)](https://www.electionguard.vote) [![ElectionGuard Specification 1.0.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard%20Specification-1.0.0-yellow)](https://www.electionguard.vote)","title":"Badges"},{"location":"spec/Data_Format/","text":"Data Format Work in Progress This is a work in progress. Feel free to contribute. Schema These are JSON schema files that can be used to verify the schema of the setup files like the manifest pre-election and the election record files post-election. Election Manifest / Manifest - Election manifest Context / CiphertextElectionContext - Context for encryption for specific election Constants / ElectionConstants - Constants of election Encryption Device / EncryptionDevice - Encryption device information Ceremony Guardian / GuardianRecord - Single guardian's record Lagrange Coefficients / LagrangeCoefficientsRecord - Lagrange coefficients Ballot Ballot / PlaintextBallot - Plaintext ballot Encrypted Ballot / CiphertextBallot - Encrypted ballot Submitted Ballot / SubmittedBallot - Cast or spoiled/challenged ballot Tally Tally / PlaintextTally - Plaintext tally Encrypted Tally / PublishedCiphertextTally - Encrypted tally","title":"Data Format"},{"location":"spec/Data_Format/#data-format","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Data Format"},{"location":"spec/Data_Format/#schema","text":"These are JSON schema files that can be used to verify the schema of the setup files like the manifest pre-election and the election record files post-election.","title":"Schema"},{"location":"spec/Data_Format/#election","text":"Manifest / Manifest - Election manifest Context / CiphertextElectionContext - Context for encryption for specific election Constants / ElectionConstants - Constants of election Encryption Device / EncryptionDevice - Encryption device information","title":"Election"},{"location":"spec/Data_Format/#ceremony","text":"Guardian / GuardianRecord - Single guardian's record Lagrange Coefficients / LagrangeCoefficientsRecord - Lagrange coefficients","title":"Ceremony"},{"location":"spec/Data_Format/#ballot","text":"Ballot / PlaintextBallot - Plaintext ballot Encrypted Ballot / CiphertextBallot - Encrypted ballot Submitted Ballot / SubmittedBallot - Cast or spoiled/challenged ballot","title":"Ballot"},{"location":"spec/Data_Format/#tally","text":"Tally / PlaintextTally - Plaintext tally Encrypted Tally / PublishedCiphertextTally - Encrypted tally","title":"Tally"},{"location":"spec/0.85.0/1_Overview/","text":"ElectionGuard Specification Download Specification No web version of this specification is available at this time. Download specification here","title":"v0.85.0"},{"location":"spec/0.85.0/1_Overview/#electionguard-specification","text":"Download Specification No web version of this specification is available at this time. Download specification here","title":"ElectionGuard Specification"},{"location":"spec/0.95.0/11_Applications/","text":"Applications to end-to-end verifiability and risk-limiting audits The methods described in this specification can be used to enable either end-to-end (E2E) verifiability or enhanced risk-limiting audits (RLAs). In both cases, the ballots are individually encrypted and proofs are provided to allow observers to verify that the set of encrypted ballots is consistent with the announced tallies in an election. In the case of E2E-verifiability, voters are given tracking codes to enable them to confirm that their individual ballots are correctly recorded amongst the set of encrypted ballots. In the case of RLAs, encrypted ballots are randomly selected and compared against physical ballots to obtain confidence that the physical records match the electronic records. To support enhanced risk-limiting audits (RLAs), it may be desirable to encrypt the master nonce of each ballot with a simple administrative key rather than the \u201cheavyweight\u201d election encryption key. This streamlines the process for decrypting an encrypted ballot that has been selected for audit. It should be noted that the privacy risks of revealing decrypted ballots are substantially reduced in the RLA case since voters are not given tracking codes that could be used to associate them with individual ballots. The primary risk is a coercion threat (e.g., via pattern voting) that only manifests if the full set of ballots were to be decrypted. While the administratively encrypted nonce can be stored in an electronic record alongside each encrypted ballot, one appealing RLA instantiation is for the administrative encryption of a ballot\u2019s nonce to be printed directly onto the physical ballot. This allows an RLA to proceed by randomly selecting an encrypted ballot, fetching the associated physical ballot, extracting the nonce from its encryption on the physical ballot, using the nonce to decrypt the electronic record, and then comparing the physical ballot contents with those of the electronic record. A malicious actor with an administrative decryption key would need to go to each individual physical ballot to obtain the nonces necessary to decrypt all of the encrypted ballots, and the access to do so would enable this malicious actor to obtain all of the open ballots without necessitating the administrative decryption key. If E2E-verifiability and enhanced RLAs are both provided in the same election, there must be separate ballot encryptions (ideally, but not necessary, using separate election encryption keys) of each ballot. The E2E-verifiable data set must be distinguished from the enhanced RLA data set. Using the same data set for both applications would compromise voter privacy for voters whose ballots are selected for auditing.","title":"Applications"},{"location":"spec/0.95.0/11_Applications/#applications-to-end-to-end-verifiability-and-risk-limiting-audits","text":"The methods described in this specification can be used to enable either end-to-end (E2E) verifiability or enhanced risk-limiting audits (RLAs). In both cases, the ballots are individually encrypted and proofs are provided to allow observers to verify that the set of encrypted ballots is consistent with the announced tallies in an election. In the case of E2E-verifiability, voters are given tracking codes to enable them to confirm that their individual ballots are correctly recorded amongst the set of encrypted ballots. In the case of RLAs, encrypted ballots are randomly selected and compared against physical ballots to obtain confidence that the physical records match the electronic records. To support enhanced risk-limiting audits (RLAs), it may be desirable to encrypt the master nonce of each ballot with a simple administrative key rather than the \u201cheavyweight\u201d election encryption key. This streamlines the process for decrypting an encrypted ballot that has been selected for audit. It should be noted that the privacy risks of revealing decrypted ballots are substantially reduced in the RLA case since voters are not given tracking codes that could be used to associate them with individual ballots. The primary risk is a coercion threat (e.g., via pattern voting) that only manifests if the full set of ballots were to be decrypted. While the administratively encrypted nonce can be stored in an electronic record alongside each encrypted ballot, one appealing RLA instantiation is for the administrative encryption of a ballot\u2019s nonce to be printed directly onto the physical ballot. This allows an RLA to proceed by randomly selecting an encrypted ballot, fetching the associated physical ballot, extracting the nonce from its encryption on the physical ballot, using the nonce to decrypt the electronic record, and then comparing the physical ballot contents with those of the electronic record. A malicious actor with an administrative decryption key would need to go to each individual physical ballot to obtain the nonces necessary to decrypt all of the encrypted ballots, and the access to do so would enable this malicious actor to obtain all of the open ballots without necessitating the administrative decryption key. If E2E-verifiability and enhanced RLAs are both provided in the same election, there must be separate ballot encryptions (ideally, but not necessary, using separate election encryption keys) of each ballot. The E2E-verifiable data set must be distinguished from the enhanced RLA data set. Using the same data set for both applications would compromise voter privacy for voters whose ballots are selected for auditing.","title":"Applications to end-to-end verifiability and risk-limiting audits"},{"location":"spec/0.95.0/12_Acknowledgements/","text":"Acknowledgements The author is happy to thank Nicholas Boucher, Joey Dodds, Gerald Doussot, Aleks Essex, Rainbow Huang, Chris Jeuell, Luke Myers, Dan Shumow, Vanessa Teague, Aaron Tomb, Daniel Wagner, Jake Waksbaum, Matt Wilhelm, and Greg Zaverucha for many helpful comments and suggestions on earlier versions of this specification.","title":"Acknowledgements"},{"location":"spec/0.95.0/12_Acknowledgements/#acknowledgements","text":"The author is happy to thank Nicholas Boucher, Joey Dodds, Gerald Doussot, Aleks Essex, Rainbow Huang, Chris Jeuell, Luke Myers, Dan Shumow, Vanessa Teague, Aaron Tomb, Daniel Wagner, Jake Waksbaum, Matt Wilhelm, and Greg Zaverucha for many helpful comments and suggestions on earlier versions of this specification.","title":"Acknowledgements"},{"location":"spec/0.95.0/1_Overview/","text":"ElectionGuard Specification Download Specification Web version is under construction at this time. Download full specification here . Overview This document describes the technical details of the ElectionGuard toolkit which can be used in conjunction with many new and existing voting systems to enable both end-to-end (E2E) verifiability and privacy-enhanced risk-limiting audits (RLAs). ElectionGuard is not a complete election system. It instead provides components that are designed to be flexible and to promote innovation by election officials and system developers. When properly used, it can promote voter confidence by empowering voters to independently verify the accuracy of election results. End-to-end (E2E) verifiability An E2E-verifiable election provides artifacts which allow voters to confirm that their votes have been accurately recorded and counted. Specifically, an election is End-to-end (E2E) verifiable if two properties are achieved. Individual voters can verify that their votes have been accurately recorded. Voters and observers can verify that the recorded votes have been accurately counted. An E2E-verifiable tally can be used as the primary tally in an election or as a verifiable secondary tally alongside traditional methods. ElectionGuard is compatible with in-person voting \u2013 either using an electronic ballot-marking device or an optical scanner capable of reading hand-marked or machine-marked ballots, with voting by mail, and even with Internet voting. Risk-limiting audits (RLAs) RLAs offer election administrators efficient methods to validate reported election tallies against physical ballot records. There are several varieties of RLAs, but the most efficient and practical are ballot-comparison audits in which electronic cast-vote records (CVRs) are individually compared against physical ballots. The challenge with ballot-comparison audits is that public release of the full set of CVRs can compromise voter privacy while an audit without public disclosure of CVRs offers no basis for public confidence in the outcome. ElectionGuard can bridge this gap by enabling public disclosure of encrypted ballots that can matched directly to physical ballots selected for auditing and can also be proven to match the reported tallies. About this specification This specification can be used by expert reviewers to evaluate the details of the ElectionGuard process and by independent parties to write ElectionGuard verifiers to confirm the consistency of election artifacts with announced election results. The details of the ElectionGuard Application Programming Interface (API) are provided in a separate document.","title":"Overview"},{"location":"spec/0.95.0/1_Overview/#electionguard-specification","text":"Download Specification Web version is under construction at this time. Download full specification here .","title":"ElectionGuard Specification"},{"location":"spec/0.95.0/1_Overview/#overview","text":"This document describes the technical details of the ElectionGuard toolkit which can be used in conjunction with many new and existing voting systems to enable both end-to-end (E2E) verifiability and privacy-enhanced risk-limiting audits (RLAs). ElectionGuard is not a complete election system. It instead provides components that are designed to be flexible and to promote innovation by election officials and system developers. When properly used, it can promote voter confidence by empowering voters to independently verify the accuracy of election results.","title":"Overview"},{"location":"spec/0.95.0/1_Overview/#end-to-end-e2e-verifiability","text":"An E2E-verifiable election provides artifacts which allow voters to confirm that their votes have been accurately recorded and counted. Specifically, an election is End-to-end (E2E) verifiable if two properties are achieved. Individual voters can verify that their votes have been accurately recorded. Voters and observers can verify that the recorded votes have been accurately counted. An E2E-verifiable tally can be used as the primary tally in an election or as a verifiable secondary tally alongside traditional methods. ElectionGuard is compatible with in-person voting \u2013 either using an electronic ballot-marking device or an optical scanner capable of reading hand-marked or machine-marked ballots, with voting by mail, and even with Internet voting.","title":"End-to-end (E2E) verifiability"},{"location":"spec/0.95.0/1_Overview/#risk-limiting-audits-rlas","text":"RLAs offer election administrators efficient methods to validate reported election tallies against physical ballot records. There are several varieties of RLAs, but the most efficient and practical are ballot-comparison audits in which electronic cast-vote records (CVRs) are individually compared against physical ballots. The challenge with ballot-comparison audits is that public release of the full set of CVRs can compromise voter privacy while an audit without public disclosure of CVRs offers no basis for public confidence in the outcome. ElectionGuard can bridge this gap by enabling public disclosure of encrypted ballots that can matched directly to physical ballots selected for auditing and can also be proven to match the reported tallies.","title":"Risk-limiting audits (RLAs)"},{"location":"spec/0.95.0/1_Overview/#about-this-specification","text":"This specification can be used by expert reviewers to evaluate the details of the ElectionGuard process and by independent parties to write ElectionGuard verifiers to confirm the consistency of election artifacts with announced election results. The details of the ElectionGuard Application Programming Interface (API) are provided in a separate document.","title":"About this specification"},{"location":"spec/0.95.0/2_ElectionGuard_Structure/","text":"ElectionGuard Structure In an election, a set of guardians is enlisted to serve as trustees who manage cryptographic keys. The members of a canvassing board can serve as guardians. Prior to the commencement of voting or auditing, the guardians work together to form a public encryption key that will be used to encrypt individual ballots. After the conclusion of voting or auditing, a quorum of guardians is necessary to produce the artifacts required to enable public verification of the tally. Key Generation Prior to the start of voting (for an E2E-verifiable election) or auditing (for an RLA), the election guardians participate in a process wherein they generate public keys to be used in the election. Each guardian generates an election key \u2013 for use in encrypting votes \u2013 and an auxiliary key \u2013 for use in encrypting other data. 1 Additional keys are generated to facilitate sharing of private keys so that the election verifiable data can be produced after voting or auditing is complete \u2013 even if not all guardians are available at that time. The key generation ceremony begins with each guardian publishing its public keys together with proofs of knowledge of the associated private keys. Once all of the public keys are published, each guardian uses each other guardian\u2019s public auxiliary key to encrypt shares of its own private keys. Finally, each guardian decrypts the shares it receives from other guardians and checks them for consistency. If the received shares verify, the receiving guardian announces its completion. If any shares fail to verify, the receiving guardian challenges the sender. In this case, the sender is obliged to reveal the shares it sent. If it does so and the shares verify, the ceremony concludes and the election proceeds. If a challenged guardian fails to produce key shares that verify, that guardian is removed and the key generation ceremony restarts with a replacement guardian. Ballot Encryption In most uses, the election system makes a single call to the ElectionGuard API after each voter completes the process of making selections or with each ballot to be encrypted for an RLA. ElectionGuard will encrypt the selections made by the voter and return a verification code which the system should give to the voter. 2 This is the only point where an existing election system must interface with ElectionGuard . In certain vote-by-mail scenarios and when ElectionGuard is used within an RLA, cast-vote records can be provided in batch without any interface between the voting equipment and ElectionGuard . There is no need to provide verification codes in the RLA scenario. The encrypted ballots are published along with non-interactive zero-knowledge proof of their integrity. The encrypted method used herein has a homomorphic property which allows the encrypted ballots to be combined into a single aggregate ballot which consists of encryptions of the election tallies. Verifiable Decryption In the final step, election guardians independently use their secret keys to decrypt the election tallies and associated verification data. It is not necessary for all guardians to be available to complete this step. If some guardians are missing, a quorum of guardians can use the previously shared key fragments to reconstruct the missing verification data. Observers can use this open specification and/or accompanying materials to write election verifiers that can confirm the integrity of each encrypted ballot, the correct aggregation of these ballots, and the accurate decryption of election tallies. The details of the ElectionGuard Application Programming Interface (API) are included in a separate document. The principal purposes of this document are to specify the functionality of the ElectionGuard toolkit and to provide details necessary for independent parties to write election verifiers that consume the artifacts produced by the toolkit. While the format of the election keys is critical to the process and carefully delineated in this document, the auxiliary keys are for internal use only and their format is left up to individual implementations. \u21a9 The verification code is not necessary for RLA usage. \u21a9","title":"Structure"},{"location":"spec/0.95.0/2_ElectionGuard_Structure/#electionguard-structure","text":"In an election, a set of guardians is enlisted to serve as trustees who manage cryptographic keys. The members of a canvassing board can serve as guardians. Prior to the commencement of voting or auditing, the guardians work together to form a public encryption key that will be used to encrypt individual ballots. After the conclusion of voting or auditing, a quorum of guardians is necessary to produce the artifacts required to enable public verification of the tally.","title":"ElectionGuard Structure"},{"location":"spec/0.95.0/2_ElectionGuard_Structure/#key-generation","text":"Prior to the start of voting (for an E2E-verifiable election) or auditing (for an RLA), the election guardians participate in a process wherein they generate public keys to be used in the election. Each guardian generates an election key \u2013 for use in encrypting votes \u2013 and an auxiliary key \u2013 for use in encrypting other data. 1 Additional keys are generated to facilitate sharing of private keys so that the election verifiable data can be produced after voting or auditing is complete \u2013 even if not all guardians are available at that time. The key generation ceremony begins with each guardian publishing its public keys together with proofs of knowledge of the associated private keys. Once all of the public keys are published, each guardian uses each other guardian\u2019s public auxiliary key to encrypt shares of its own private keys. Finally, each guardian decrypts the shares it receives from other guardians and checks them for consistency. If the received shares verify, the receiving guardian announces its completion. If any shares fail to verify, the receiving guardian challenges the sender. In this case, the sender is obliged to reveal the shares it sent. If it does so and the shares verify, the ceremony concludes and the election proceeds. If a challenged guardian fails to produce key shares that verify, that guardian is removed and the key generation ceremony restarts with a replacement guardian.","title":"Key Generation"},{"location":"spec/0.95.0/2_ElectionGuard_Structure/#ballot-encryption","text":"In most uses, the election system makes a single call to the ElectionGuard API after each voter completes the process of making selections or with each ballot to be encrypted for an RLA. ElectionGuard will encrypt the selections made by the voter and return a verification code which the system should give to the voter. 2 This is the only point where an existing election system must interface with ElectionGuard . In certain vote-by-mail scenarios and when ElectionGuard is used within an RLA, cast-vote records can be provided in batch without any interface between the voting equipment and ElectionGuard . There is no need to provide verification codes in the RLA scenario. The encrypted ballots are published along with non-interactive zero-knowledge proof of their integrity. The encrypted method used herein has a homomorphic property which allows the encrypted ballots to be combined into a single aggregate ballot which consists of encryptions of the election tallies.","title":"Ballot Encryption"},{"location":"spec/0.95.0/2_ElectionGuard_Structure/#verifiable-decryption","text":"In the final step, election guardians independently use their secret keys to decrypt the election tallies and associated verification data. It is not necessary for all guardians to be available to complete this step. If some guardians are missing, a quorum of guardians can use the previously shared key fragments to reconstruct the missing verification data. Observers can use this open specification and/or accompanying materials to write election verifiers that can confirm the integrity of each encrypted ballot, the correct aggregation of these ballots, and the accurate decryption of election tallies. The details of the ElectionGuard Application Programming Interface (API) are included in a separate document. The principal purposes of this document are to specify the functionality of the ElectionGuard toolkit and to provide details necessary for independent parties to write election verifiers that consume the artifacts produced by the toolkit. While the format of the election keys is critical to the process and carefully delineated in this document, the auxiliary keys are for internal use only and their format is left up to individual implementations. \u21a9 The verification code is not necessary for RLA usage. \u21a9","title":"Verifiable Decryption"},{"location":"spec/0.95.0/3_ElectionGuard_Components/","text":"ElectionGuard Components This document describes the four principal components of ElectionGuard. Baseline Parameters \u2013 These are general parameters that are standard in every election. An alternate means for generating parameters is described, but the burden of verifying an election is increased if alternate parameters are used because a verifier would need to verify the proper construction of any alternate parameters. Key Generation \u2013 Prior to each individual election, guardians must generate individual public-private key pairs and exchange shares of private keys to enable completion of an election even if some guardians become unavailable. Although it is preferred to generate new keys for each election, it is permissible to use the same keys for multiple elections so long as the set of guardians remains the same. A complete new set of keys must be generated if even a single guardian is replaced. Ballot Encryption \u2013 While encrypting the contents of a ballot is a relatively simple operation, most of the work of ElectionGuard is the process of creating externallyverifiable artifacts to prove that each encrypted ballot is well-formed (i.e., its decryption is a legitimate ballot without overvotes or improper values). Verifiable Decryption \u2013 At the conclusion of each election, guardians use their private keys to produce election tallies together with verifiable artifacts that prove that the tallies are correct. Notation In the remainder of this specification, the following notation will be used. \u2022 \\(\u2124 = \\{\u2026 , \u22123, \u22122, \u22121, 0, 1, 2, 3, \u2026 \\}\\) is the set of integers. \u2022 \\(\u2124_n = \\{0, 1, 2, \u2026 , n \u2212 1\\}\\) is the additive group of the integers modulo \\(p\\) . \u2022 \\(\u2124_n^\u2217\\) is the multiplicative subgroup of \\(\u2124_n\\) . When \\(p\\) is a prime, \\(\u2124_p^* = \\{1, 2, 3, \u2026 , p \u2212 1\\}.\\) \u2022 \\(\u2124_p^r\\) is the set of \\(r^{th}\\) -residues in \\(\u2124_p^*\\) . Formally, \\(\u2124_p^r = \\{y \\in \u2124_p^*\\) for which \\(\\exists x \\in \u2124_p^\u2217\\) such that \\(y = x^r \\bmod p\\}\\) . When \\(p\\) is a prime for which \\(p \u2212 1 = qr\\) with \\(q\\) a prime that is not a divisor of integer \\(r\\) , then \\(\u2124_p^r\\) is an order \\(q\\) cyclic subgroup of \\(\u2124_p^\u2217\\) and for each \\(y \\in \u2124_p^\u2217, y \\in \u2124_p^r\\) if and only if \\(y^q \\bmod p = 1\\) . \u2022 \\(x \\equiv_n y\\) is the predicate that is true if and only if \\(x \\bmod n = y \\bmod n\\) . \u2022 The function \\(H()\\) shall be used to designate the SHA-256 hash function (as defined in NIST PUB FIPS 180-4 1 ). \u2022 In general, the variable pairs \\((\\alpha, \\beta)\\) , \\((a, b)\\) , and \\((A, B)\\) will be used to denote encryptions. Specifically, \\((\\alpha, \\beta)\\) will be used to designate encryptions of votes (always an encryption of a zero or a one), \\((A, B)\\) will be used to denote aggregations of encryptions \u2013 which may be encryptions of larger values, and \\((a, b)\\) will be used to denote encryption commitments used to prove properties of other encryptions. Encryption of Votes Encryption of votes in ElectionGuard is performed using an exponential form of the ElGamal cryptosystem. 2 Primes \\(p\\) and \\(q\\) are publicly fixed such that \\(q\\) is not a divisor of \\(r = \\frac {p\u22121} {q}\\) . A generator \\(g\\) of the order \\(q\\) subgroup \\(\u2124_p^r\\) is also fixed. (Any \\(g = x^r \\bmod p\\) for which \\(x \\in \u2124_p^*\\) suffices so long as \\(g \\neq 1\\) .) A public-private key pair can be chosen by selecting a random \\(s \\in \u2124_q\\) as a private key and publishing \\(K = g^s \\bmod p\\) as a public key. 3 A message \\(M \\in \u2124_p^r\\) is then encrypted by selecting a random nonce \\(R \\in \u2124_q\\) and forming the pair \\((\\alpha, \\beta) = (g^R \\bmod p,g^M \u22c5 K^R \\bmod p)\\) . An encryption \\((\\alpha, \\beta)\\) can be decrypted by the holder of the secret \\(s\\) as \\(\\frac \\beta {\\alpha^s} \\bmod p =\\frac {g^M \u22c5 K^R} {(g^R)^s} \\bmod p = \\frac {g^M \u22c5 (g^s)^R} {(g^R)^s} \\bmod p = \\frac {g^M \u22c5 g^{Rs}} {g^{Rs}} \\bmod p = g^M \\bmod p.\\) The value of \\(M\\) can be computed from \\(g^M \\bmod p\\) as long as the message \\(M\\) is limited to a small, known set of options. 4 Only two possible messages are encrypted in this way by ElectionGuard . An encryption of one is used to indicate that an option is selected, and an encryption of zero is used to indicate that an option is not selected. Homomorphic Properties A fundamental quality of the exponential form of ElGamal described above is its additively homomorphic property. If two messages \\(M_1\\) and \\(M_2\\) are respectively encrypted as \\((A_1,B_1) =(g^{R_1} \\bmod p, g^{M_1} \u22c5 K^{R_1} \\bmod p)\\) and \\((A_2,B_2) = (g^{R_2} \\bmod p, g^{M_2} \u22c5 K^{R_2} \\bmod p)\\) , then the component-wise product \\((A, B) = (A_1A_2 \\bmod p,B_1B_2 \\bmod p) = (g^{R_1+R_2} \\bmod p, g^{M_1+M_2}\u22c5K^{R_1+R_2} \\bmod p)\\) is an encryption of the sum \\(M_1 + M_2\\) . (There is an implicit assumption here that \\((M_1 + M_2) < q\\) which is easily satisfied when \\(M_1\\) and \\(M_2\\) are both small. If \\((R_1 + R_2) \u2265 q, (R_1 + R_2) \\bmod q\\) may be substituted without changing the equation since \\(g^q \\bmod p = 1.)\\) This additively homomorphic property is used in two important ways in ElectionGuard. First, all of the encryptions of a single option across ballots can be multiplied to form an encryption of the sum of the individual values. Since the individual values are one on ballots that select that option and zero otherwise, the sum is the tally of votes for that option and the product of the individual encryptions is an encryption of the tally. The other use is to sum all of the selections made in a single contest on a single ballot. After demonstrating that each option is an encryption of either zero or one, the product of the encryptions indicates the number of options that are encryptions of one, and this can be used to show that no more ones than permitted are among the encrypted options \u2013 i.e., that no more options were selected than permitted. However, as will be described below, it is possible for a holder of a nonce \\(R\\) to prove to a third party that a pair \\((\\alpha, \\beta)\\) is an encryption of \\(M\\) without revealing the nonce \\(R\\) and without access to the secret \\(s\\) . Non-Interactive Zero-Knowledge (NIZK) Proofs ElectionGuard provides numerous proofs about encryption keys, encrypted ballots, and election tallies using the following four techniques. A Schnorr proof 5 allows the holder of an ElGamal secret key \\(s\\) to interactively prove possession of \\(s\\) without revealing \\(s\\) . A Chaum-Pedersen proof 6 allows an ElGamal encryption to be interactively proven to decrypt to a particular value without revealing the nonce used for encryption or the secret decryption key \\(s\\) . (This proof can be constructed with access to either the nonce used for encryption or the secret decryption key.) The Cramer-Damg\u00e5rd-Schoenmakers technique 7 enables a disjunction to be interactively proven without revealing which disjunct is true. The Fiat-Shamir heuristic 8 allows interactive proofs to be converted into noninteractive proofs. Using a combination of the above techniques, it is possible for ElectionGuard to demonstrate that keys are properly chosen, that ballots are properly formed, and that decryptions match claimed values. Threshold Encryption Threshold ElGamal encryption is used for encryption of ballots and other data. This form of encryption makes it very easy to combine individual guardian public keys into a single public key. It also offers a homomorphic property that allows individual encrypted votes to be combined to form encrypted tallies. The guardians of an election will each generate a public-private key pair. The public keys will then be combined (as described in the following section) into a single election public key which is used to encrypt all selections made by voters in the election. Ideally, at the conclusion of the election, each guardian will use its private key to form a verifiable partial decryption of each tally. These partial decryptions will then be combined to form full verifiable decryptions of the election tallies. To accommodate the possibility that one or more of the guardians will not be available at the conclusion of the election to form their partial decryptions, the guardians will cryptographically share 9 their private keys amongst each other during key generation in a manner to be detailed in the next section. A pre-determined threshold quorum value \\((k)\\) out of the \\((n)\\) guardians will be necessary to produce a full decryption. NIST (2015) Secure Hash Standard (SHS). In: FIPS 180-4. https://csrc.nist.gov/publications/detail/fips/180/4/final \u21a9 ElGamal T. (1985) A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms. In: Blakley G.R., Chaum D. (eds) Advances in Cryptology. CRYPTO 1984. Lecture Notes in Computer Science, vol 196. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007/3-540-39568-7_2.pdf \u21a9 As will be seen below, the actual public key used to encrypt votes will be a combination of separately-generated public keys. So no entity will ever be in possession of a private key that can be used to decrypt votes. \u21a9 The simplest way to compute \\(M\\) from \\(g^M \\bmod p\\) is an exhaustive search through possible values of \\(M\\) . Alternatively, a table of pairing each possible value of \\(g^M \\bmod p\\) can be pre-computed. A final option which can accommodate a larger space of possible values for \\(M\\) is to use Shanks\u2019s baby-step giant-step method as described in the 1971 paper \u201cClass Number, a Theory of Factorization and Genera,\u201d Proceedings of Symposium in Pure Mathematics, Vol. 20, American Mathematical Society, Providence, 1971, pp. 415-440. \u21a9 Schnorr C.P. (1990) Efficient Identification and Signatures for Smart Cards. In: Brassard G. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 89 Proceedings. CRYPTO 1989. Lecture Notes in Computer Science, vol 435. Springer, New York, NY. https://link.springer.com/content/pdf/10.1007%2F0-387-34805-0_22.pdf \u21a9 Chaum D., Pedersen T.P. (1993) Wallet Databases with Observers. In: Brickell E.F. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 92. CRYPTO 1992. Lecture Notes in Computer Science, vol 740. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3-540-48071-4_7.pdf \u21a9 Cramer R., Damg\u00e5rd I., Schoenmakers B. (1994) Proofs of Partial Knowledge and Simplified Design of Witness Hiding Protocols. In: Desmedt Y.G. (eds) Advances in Cryptology \u2014 CRYPTO \u201994. CRYPTO 1994. Lecture Notes in Computer Science, vol 839. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3-540-48658-5_19.pdf \u21a9 Fiat A., Shamir A. (1987) How To Prove Yourself: Practical Solutions to Identification and Signature Problems. In: Odlyzko A.M. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 86. CRYPTO 1986. Lecture Notes in Computer Science, vol 263. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3- 540-47721-7_12.pdf \u21a9 Shamir A. How to Share a Secret. (1979) Communications of the ACM. \u21a9","title":"Components"},{"location":"spec/0.95.0/3_ElectionGuard_Components/#electionguard-components","text":"This document describes the four principal components of ElectionGuard. Baseline Parameters \u2013 These are general parameters that are standard in every election. An alternate means for generating parameters is described, but the burden of verifying an election is increased if alternate parameters are used because a verifier would need to verify the proper construction of any alternate parameters. Key Generation \u2013 Prior to each individual election, guardians must generate individual public-private key pairs and exchange shares of private keys to enable completion of an election even if some guardians become unavailable. Although it is preferred to generate new keys for each election, it is permissible to use the same keys for multiple elections so long as the set of guardians remains the same. A complete new set of keys must be generated if even a single guardian is replaced. Ballot Encryption \u2013 While encrypting the contents of a ballot is a relatively simple operation, most of the work of ElectionGuard is the process of creating externallyverifiable artifacts to prove that each encrypted ballot is well-formed (i.e., its decryption is a legitimate ballot without overvotes or improper values). Verifiable Decryption \u2013 At the conclusion of each election, guardians use their private keys to produce election tallies together with verifiable artifacts that prove that the tallies are correct.","title":"ElectionGuard Components"},{"location":"spec/0.95.0/3_ElectionGuard_Components/#notation","text":"In the remainder of this specification, the following notation will be used. \u2022 \\(\u2124 = \\{\u2026 , \u22123, \u22122, \u22121, 0, 1, 2, 3, \u2026 \\}\\) is the set of integers. \u2022 \\(\u2124_n = \\{0, 1, 2, \u2026 , n \u2212 1\\}\\) is the additive group of the integers modulo \\(p\\) . \u2022 \\(\u2124_n^\u2217\\) is the multiplicative subgroup of \\(\u2124_n\\) . When \\(p\\) is a prime, \\(\u2124_p^* = \\{1, 2, 3, \u2026 , p \u2212 1\\}.\\) \u2022 \\(\u2124_p^r\\) is the set of \\(r^{th}\\) -residues in \\(\u2124_p^*\\) . Formally, \\(\u2124_p^r = \\{y \\in \u2124_p^*\\) for which \\(\\exists x \\in \u2124_p^\u2217\\) such that \\(y = x^r \\bmod p\\}\\) . When \\(p\\) is a prime for which \\(p \u2212 1 = qr\\) with \\(q\\) a prime that is not a divisor of integer \\(r\\) , then \\(\u2124_p^r\\) is an order \\(q\\) cyclic subgroup of \\(\u2124_p^\u2217\\) and for each \\(y \\in \u2124_p^\u2217, y \\in \u2124_p^r\\) if and only if \\(y^q \\bmod p = 1\\) . \u2022 \\(x \\equiv_n y\\) is the predicate that is true if and only if \\(x \\bmod n = y \\bmod n\\) . \u2022 The function \\(H()\\) shall be used to designate the SHA-256 hash function (as defined in NIST PUB FIPS 180-4 1 ). \u2022 In general, the variable pairs \\((\\alpha, \\beta)\\) , \\((a, b)\\) , and \\((A, B)\\) will be used to denote encryptions. Specifically, \\((\\alpha, \\beta)\\) will be used to designate encryptions of votes (always an encryption of a zero or a one), \\((A, B)\\) will be used to denote aggregations of encryptions \u2013 which may be encryptions of larger values, and \\((a, b)\\) will be used to denote encryption commitments used to prove properties of other encryptions.","title":"Notation"},{"location":"spec/0.95.0/3_ElectionGuard_Components/#encryption-of-votes","text":"Encryption of votes in ElectionGuard is performed using an exponential form of the ElGamal cryptosystem. 2 Primes \\(p\\) and \\(q\\) are publicly fixed such that \\(q\\) is not a divisor of \\(r = \\frac {p\u22121} {q}\\) . A generator \\(g\\) of the order \\(q\\) subgroup \\(\u2124_p^r\\) is also fixed. (Any \\(g = x^r \\bmod p\\) for which \\(x \\in \u2124_p^*\\) suffices so long as \\(g \\neq 1\\) .) A public-private key pair can be chosen by selecting a random \\(s \\in \u2124_q\\) as a private key and publishing \\(K = g^s \\bmod p\\) as a public key. 3 A message \\(M \\in \u2124_p^r\\) is then encrypted by selecting a random nonce \\(R \\in \u2124_q\\) and forming the pair \\((\\alpha, \\beta) = (g^R \\bmod p,g^M \u22c5 K^R \\bmod p)\\) . An encryption \\((\\alpha, \\beta)\\) can be decrypted by the holder of the secret \\(s\\) as \\(\\frac \\beta {\\alpha^s} \\bmod p =\\frac {g^M \u22c5 K^R} {(g^R)^s} \\bmod p = \\frac {g^M \u22c5 (g^s)^R} {(g^R)^s} \\bmod p = \\frac {g^M \u22c5 g^{Rs}} {g^{Rs}} \\bmod p = g^M \\bmod p.\\) The value of \\(M\\) can be computed from \\(g^M \\bmod p\\) as long as the message \\(M\\) is limited to a small, known set of options. 4 Only two possible messages are encrypted in this way by ElectionGuard . An encryption of one is used to indicate that an option is selected, and an encryption of zero is used to indicate that an option is not selected.","title":"Encryption of Votes"},{"location":"spec/0.95.0/3_ElectionGuard_Components/#homomorphic-properties","text":"A fundamental quality of the exponential form of ElGamal described above is its additively homomorphic property. If two messages \\(M_1\\) and \\(M_2\\) are respectively encrypted as \\((A_1,B_1) =(g^{R_1} \\bmod p, g^{M_1} \u22c5 K^{R_1} \\bmod p)\\) and \\((A_2,B_2) = (g^{R_2} \\bmod p, g^{M_2} \u22c5 K^{R_2} \\bmod p)\\) , then the component-wise product \\((A, B) = (A_1A_2 \\bmod p,B_1B_2 \\bmod p) = (g^{R_1+R_2} \\bmod p, g^{M_1+M_2}\u22c5K^{R_1+R_2} \\bmod p)\\) is an encryption of the sum \\(M_1 + M_2\\) . (There is an implicit assumption here that \\((M_1 + M_2) < q\\) which is easily satisfied when \\(M_1\\) and \\(M_2\\) are both small. If \\((R_1 + R_2) \u2265 q, (R_1 + R_2) \\bmod q\\) may be substituted without changing the equation since \\(g^q \\bmod p = 1.)\\) This additively homomorphic property is used in two important ways in ElectionGuard. First, all of the encryptions of a single option across ballots can be multiplied to form an encryption of the sum of the individual values. Since the individual values are one on ballots that select that option and zero otherwise, the sum is the tally of votes for that option and the product of the individual encryptions is an encryption of the tally. The other use is to sum all of the selections made in a single contest on a single ballot. After demonstrating that each option is an encryption of either zero or one, the product of the encryptions indicates the number of options that are encryptions of one, and this can be used to show that no more ones than permitted are among the encrypted options \u2013 i.e., that no more options were selected than permitted. However, as will be described below, it is possible for a holder of a nonce \\(R\\) to prove to a third party that a pair \\((\\alpha, \\beta)\\) is an encryption of \\(M\\) without revealing the nonce \\(R\\) and without access to the secret \\(s\\) .","title":"Homomorphic Properties"},{"location":"spec/0.95.0/3_ElectionGuard_Components/#non-interactive-zero-knowledge-nizk-proofs","text":"ElectionGuard provides numerous proofs about encryption keys, encrypted ballots, and election tallies using the following four techniques. A Schnorr proof 5 allows the holder of an ElGamal secret key \\(s\\) to interactively prove possession of \\(s\\) without revealing \\(s\\) . A Chaum-Pedersen proof 6 allows an ElGamal encryption to be interactively proven to decrypt to a particular value without revealing the nonce used for encryption or the secret decryption key \\(s\\) . (This proof can be constructed with access to either the nonce used for encryption or the secret decryption key.) The Cramer-Damg\u00e5rd-Schoenmakers technique 7 enables a disjunction to be interactively proven without revealing which disjunct is true. The Fiat-Shamir heuristic 8 allows interactive proofs to be converted into noninteractive proofs. Using a combination of the above techniques, it is possible for ElectionGuard to demonstrate that keys are properly chosen, that ballots are properly formed, and that decryptions match claimed values.","title":"Non-Interactive Zero-Knowledge (NIZK) Proofs"},{"location":"spec/0.95.0/3_ElectionGuard_Components/#threshold-encryption","text":"Threshold ElGamal encryption is used for encryption of ballots and other data. This form of encryption makes it very easy to combine individual guardian public keys into a single public key. It also offers a homomorphic property that allows individual encrypted votes to be combined to form encrypted tallies. The guardians of an election will each generate a public-private key pair. The public keys will then be combined (as described in the following section) into a single election public key which is used to encrypt all selections made by voters in the election. Ideally, at the conclusion of the election, each guardian will use its private key to form a verifiable partial decryption of each tally. These partial decryptions will then be combined to form full verifiable decryptions of the election tallies. To accommodate the possibility that one or more of the guardians will not be available at the conclusion of the election to form their partial decryptions, the guardians will cryptographically share 9 their private keys amongst each other during key generation in a manner to be detailed in the next section. A pre-determined threshold quorum value \\((k)\\) out of the \\((n)\\) guardians will be necessary to produce a full decryption. NIST (2015) Secure Hash Standard (SHS). In: FIPS 180-4. https://csrc.nist.gov/publications/detail/fips/180/4/final \u21a9 ElGamal T. (1985) A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms. In: Blakley G.R., Chaum D. (eds) Advances in Cryptology. CRYPTO 1984. Lecture Notes in Computer Science, vol 196. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007/3-540-39568-7_2.pdf \u21a9 As will be seen below, the actual public key used to encrypt votes will be a combination of separately-generated public keys. So no entity will ever be in possession of a private key that can be used to decrypt votes. \u21a9 The simplest way to compute \\(M\\) from \\(g^M \\bmod p\\) is an exhaustive search through possible values of \\(M\\) . Alternatively, a table of pairing each possible value of \\(g^M \\bmod p\\) can be pre-computed. A final option which can accommodate a larger space of possible values for \\(M\\) is to use Shanks\u2019s baby-step giant-step method as described in the 1971 paper \u201cClass Number, a Theory of Factorization and Genera,\u201d Proceedings of Symposium in Pure Mathematics, Vol. 20, American Mathematical Society, Providence, 1971, pp. 415-440. \u21a9 Schnorr C.P. (1990) Efficient Identification and Signatures for Smart Cards. In: Brassard G. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 89 Proceedings. CRYPTO 1989. Lecture Notes in Computer Science, vol 435. Springer, New York, NY. https://link.springer.com/content/pdf/10.1007%2F0-387-34805-0_22.pdf \u21a9 Chaum D., Pedersen T.P. (1993) Wallet Databases with Observers. In: Brickell E.F. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 92. CRYPTO 1992. Lecture Notes in Computer Science, vol 740. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3-540-48071-4_7.pdf \u21a9 Cramer R., Damg\u00e5rd I., Schoenmakers B. (1994) Proofs of Partial Knowledge and Simplified Design of Witness Hiding Protocols. In: Desmedt Y.G. (eds) Advances in Cryptology \u2014 CRYPTO \u201994. CRYPTO 1994. Lecture Notes in Computer Science, vol 839. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3-540-48658-5_19.pdf \u21a9 Fiat A., Shamir A. (1987) How To Prove Yourself: Practical Solutions to Identification and Signature Problems. In: Odlyzko A.M. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 86. CRYPTO 1986. Lecture Notes in Computer Science, vol 263. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3- 540-47721-7_12.pdf \u21a9 Shamir A. How to Share a Secret. (1979) Communications of the ACM. \u21a9","title":"Threshold Encryption"},{"location":"spec/0.95.0/4_Baseline_Parameters/","text":"Baseline Parameters ElectionGuard uses integer ElGamal rather than elliptic-curve ElGamal in order to make construction of election verifiers as simple as possible without requiring special tools and dependencies. The exponential ElGamal used to encrypt votes is defined by a 4096-bit prime \\(p\\) and a 256-bit prime \\(q\\) which divides \\((p \u2212 1)\\) . We use \\(r = \\frac{p-1}{q}\\) to denote cofactor of \\(q\\) , and a generator \\(g\\) of the order \\(q\\) subgroup \\(\\mathbb{Z}^{r}_{p}\\) is fixed. Another parameter of an election should be a public ballot coding file. This file should list all the contests in an election, the number of selections allowed for each contest, and the options for each contest together with associations between each option and its representation on a virtual ballot. It is assumed that each contest in the ballot coding file has a unique label and that within each contest, each option also has a unique label. For instance, if Alice, Bob, and Carol are running for governor, and David and Ellen are running for senator, the ballot coding file could enable the vector \\(\u30080,1,0; 0,1\u3009\\) to be recognized as a ballot with votes for Bob as governor and Ellen as senator. The detailed format of a ballot coding file will not be specified in this document. But the contents of this file are hashed together with the prime modulus \\((p)\\) , subgroup order \\((q)\\) , generator \\((g)\\) , number of guardians \\((n)\\) , decryption quorum threshold value \\((k)\\) , date, and jurisdictional information to form a base hash code \\((Q)\\) which will be incorporated into every subsequent hash computation in the election. Standard parameters for ElectionGuard begin with the largest 256-bit prime \\(q = 2^{256} \u2212 189\\) . The hexadecimal representation of q is as follows. FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFF43 The modulus \\(p\\) is then set to be a 4096-bit prime with the following properties. The first 256 bits of \\(p\\) are all ones. The last 256 bits of \\(p\\) are all ones. \\(p \u2212 1\\) is a multiple of \\(q\\) . \\(\\frac{p\u22121}{2q}\\) is also prime. The middle 3584 bits of \\(p\\) are chosen by starting with the first 3584 bits of the Euler\u2013Mascheroni constant ( \\(\\gamma\\) ), pre-pending and appending 256 ones, and finding the smallest prime larger than this value that satisfies the above properties. This works out to \\(p = 2^{4096} \u2212 2^{3840} \u2212 1 + 2^{256}(\u230a2^{3584}\\gamma\u230b + \\delta)\\) where the value of \\(\\delta\\) is given by 1 \\[ \\delta = 495448529856135475846147600290107731951815687842437876083937612367400355133042233301. \\] The hexadecimal representation of q is as follows. FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 93C467E3 7DB0C7A4 D1BE3F81 0152CB56 A1CECC3A F65CC019 0C03DF34 709AFFBD 8E4B59FA 03A9F0EE D0649CCB 621057D1 1056AE91 32135A08 E43B4673 D74BAFEA 58DEB878 CC86D733 DBE7BF38 154B36CF 8A96D156 7899AAAE 0C09D4C8 B6B7B86F D2A1EA1D E62FF864 3EC7C271 82797722 5E6AC2F0 BD61C746 961542A3 CE3BEA5D B54FE70E 63E6D09F 8FC28658 E80567A4 7CFDE60E E741E5D8 5A7BD469 31CED822 03655949 64B83989 6FCAABCC C9B31959 C083F22A D3EE591C 32FAB2C7 448F2A05 7DB2DB49 EE52E018 2741E538 65F004CC 8E704B7C 5C40BF30 4C4D8C4F 13EDF604 7C555302 D2238D8C E11DF242 4F1B66C2 C5D238D0 744DB679 AF289048 7031F9C0 AEA1C4BB 6FE9554E E528FDF1 B05E5B25 6223B2F0 9215F371 9F9C7CCC 69DDF172 D0D62342 17FCC003 7F18B93E F5389130 B7A661E5 C26E5421 4068BBCA FEA32A67 818BD307 5AD1F5C7 E9CC3D17 37FB2817 1BAF84DB B6612B78 81C1A48E 439CD03A 92BF5222 5A2B38E6 542E9F72 2BCE15A3 81B5753E A8427633 81CCAE83 512B3051 1B32E5E8 D8036214 9AD030AA BA5F3A57 98BB22AA 7EC1B6D0 F17903F4 E234EA60 34AA8597 3F79A93F FB82A75C 47C03D43 D2F9CA02 D03199BA CEDDD453 34DBC6B5 FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF The hexadecimal representation of the cofactor \\(r = \\frac{p\u22121}{q}\\) is as follows. 1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 000000BC 93C467E3 7DB0C7A4 D1BE3F81 0152CB56 A1CECC3A F65CC019 0C03DF34 709B8AF6 A64C0CED CF2D559D A9D97F09 5C3076C6 86037619 148D2C86 C317102A FA214803 1F04440A C0FF0C9A 417A8921 2512E760 7B2501DA A4D38A2C 1410C483 6149E2BD B8C8260E 627C4646 963EFFE9 E16E495D 48BD215C 6D8EC9D1 667657A2 A1C8506F 2113FFAD 19A6B2BC 7C457604 56719183 309F874B C9ACE570 FFDA877A A2B23A2D 6F291C15 54CA2EB1 2F12CD00 9B8B8734 A64AD51E B893BD89 1750B851 62241D90 8F0C9709 879758E7 E8233EAB 3BF2D6AB 53AFA32A A153AD66 82E5A064 8897C9BE 18A0D50B ECE030C3 432336AD 9163E33F 8E7DAF49 8F14BB28 52AFFA81 4841EB18 DD5F0E89 516D5577 76285C16 071D2111 94EE1C3F 34642036 AB886E3E C28882CE 4003DEA3 35B4D935 BAE4B582 35B9FB2B AB713C8F 705A1C7D E4222020 9D6BBCAC C4673186 01565272 E4A63E38 E2499754 AE493AC1 A8E83469 EEF35CA2 7C271BC7 92EEE211 56E617B9 22EA8F71 3C22CF28 2DC5D638 5BB12868 EB781278 FA0AB2A8 958FCCB5 FFE2E5C3 61FC1744 20122B01 63CA4A46 308C8C46 C91EA745 7C1AD0D6 9FD4A7F5 29FD4A7F 529FD4A7 F529FD4A 7F529FD4 A7F529FD 4A7F529F D4A7F52A Finally, the generator \\(g\\) is chosen to be \\(g = 2^r\\bmod p\\) and has the following hexadecimal representation. 037DE384 F98F6E03 8D2A3141 825B33D5 D45EC4CC 64CFD15E 750D6798 F5196CF2 A142CDF3 3F6EF853 840EC7D4 EC804794 CFB0CFB6 5363B256 6387B98E E0E3DEF1 B706FA55 D5038FFB 4A62DCBB 93B1DDD8 D3B308DA 86D1C3A5 25EF356F E5BB5931 4E656334 80B396E1 DD4B795F 78DE07D8 6B0E2A05 BE6AF78F D7F736FC BA6C032E 26E050AF 50A03C65 FA7B6C87 F4554CB5 7F3DABCB AD8EB9D8 FDEBEEF5 8570669A CC3EDA17 DBFC47B8 B3C39AA0 8B829B28 872E62B5 D1B13A98 F09D40AC 20C2AB74 A6750E7C 8750B514 1E221C41 F55BBA31 D8E41422 B64D2CBA 7AAA0E9F D8785702 F6932825 BF45DE83 86D24900 742062C1 322B37C5 0AF18215 8090C35D A9355E6C F7F72DA3 9A2284FD FB1918B2 A2A30E69 501FA234 2B728263 DF23F1DB 8355BDE1 EB276FB3 685F3716 72CEB313 FDAB069C C9B11AB6 C59BCE62 BAAD96AA C96B0DBE 0C7E71FC B2255254 5A5D1CED EEE01E4B C0CDBDB7 6B6AD45F 09AF5E71 114A005F 93AD97B8 FE09274E 76C94B20 08926B38 CAEC94C9 5E96D628 F6BC8066 2BA06207 801328B2 C6A60526 BF7CD02D 9661385A C3B1CBDB 50F759D0 E9F61C11 A07BF421 8F299BCB 29005200 76EBD2D9 5A3DEE96 D4809EF3 4ABEB83F DBA8A12C 5CA82757 288A89C9 31CF564F 00E8A317 AE1E1D82 8E61369B A0DDBADB 10C136F8 691101AD 82DC5477 5AB83538 40D99921 97D80A6E 94B38AC4 17CDDF40 B0C73ABF 03E8E0AA Alternative parameter sets are possible. A good source for parameter generation is appendix A of FIPS \\(186-4\\) 2 . However, allowing alternate parameters would force election verifiers to recognize and check that parameters are correctly generated. Since these checks would be very different from other checks that are required of a verifier, allowing alternate parameters would add substantial complexity to election verifiers. For this reason, this version of ElectionGuard fixes the parameters as above. An ElectionGuard version 1 election verifier may assume that the baseline parameters match the parameters provided above. However, it is recommended that the above parameters be checked against the parameters of each election to accommodate the possibility of different parameters in future versions of ElectionGuard. 3 Discovering this value \\(\\delta\\) required a search through roughly 42 million values satisfying the first three of the above properties to find one for which both \\(p\\) and \\(\\frac{p-1}{2q}\\) are both prime. \u21a9 NIST (2013) Digital Signature Standard (DSS). In: FIPS 186-4. https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf \u21a9 If alternative parameters are allowed, election verifiers must confir that \\(p, q, r\\) and \\(g\\) are such that both \\(p\\) and \\(q\\) are prime (this may be done probabilistically using the Miller-Rabin algorithm), that \\(p-1 = qr\\) is satisfied, that \\(q\\) is not a divisor of \\(r\\) , that \\(1<g<p\\) , that \\(g^qq \\bmod p = 1\\) , and that generation of parameters is consistent with the sited standard. \u21a9","title":"Baseline Parameters"},{"location":"spec/0.95.0/4_Baseline_Parameters/#baseline-parameters","text":"ElectionGuard uses integer ElGamal rather than elliptic-curve ElGamal in order to make construction of election verifiers as simple as possible without requiring special tools and dependencies. The exponential ElGamal used to encrypt votes is defined by a 4096-bit prime \\(p\\) and a 256-bit prime \\(q\\) which divides \\((p \u2212 1)\\) . We use \\(r = \\frac{p-1}{q}\\) to denote cofactor of \\(q\\) , and a generator \\(g\\) of the order \\(q\\) subgroup \\(\\mathbb{Z}^{r}_{p}\\) is fixed. Another parameter of an election should be a public ballot coding file. This file should list all the contests in an election, the number of selections allowed for each contest, and the options for each contest together with associations between each option and its representation on a virtual ballot. It is assumed that each contest in the ballot coding file has a unique label and that within each contest, each option also has a unique label. For instance, if Alice, Bob, and Carol are running for governor, and David and Ellen are running for senator, the ballot coding file could enable the vector \\(\u30080,1,0; 0,1\u3009\\) to be recognized as a ballot with votes for Bob as governor and Ellen as senator. The detailed format of a ballot coding file will not be specified in this document. But the contents of this file are hashed together with the prime modulus \\((p)\\) , subgroup order \\((q)\\) , generator \\((g)\\) , number of guardians \\((n)\\) , decryption quorum threshold value \\((k)\\) , date, and jurisdictional information to form a base hash code \\((Q)\\) which will be incorporated into every subsequent hash computation in the election. Standard parameters for ElectionGuard begin with the largest 256-bit prime \\(q = 2^{256} \u2212 189\\) . The hexadecimal representation of q is as follows. FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFF43 The modulus \\(p\\) is then set to be a 4096-bit prime with the following properties. The first 256 bits of \\(p\\) are all ones. The last 256 bits of \\(p\\) are all ones. \\(p \u2212 1\\) is a multiple of \\(q\\) . \\(\\frac{p\u22121}{2q}\\) is also prime. The middle 3584 bits of \\(p\\) are chosen by starting with the first 3584 bits of the Euler\u2013Mascheroni constant ( \\(\\gamma\\) ), pre-pending and appending 256 ones, and finding the smallest prime larger than this value that satisfies the above properties. This works out to \\(p = 2^{4096} \u2212 2^{3840} \u2212 1 + 2^{256}(\u230a2^{3584}\\gamma\u230b + \\delta)\\) where the value of \\(\\delta\\) is given by 1 \\[ \\delta = 495448529856135475846147600290107731951815687842437876083937612367400355133042233301. \\] The hexadecimal representation of q is as follows. FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 93C467E3 7DB0C7A4 D1BE3F81 0152CB56 A1CECC3A F65CC019 0C03DF34 709AFFBD 8E4B59FA 03A9F0EE D0649CCB 621057D1 1056AE91 32135A08 E43B4673 D74BAFEA 58DEB878 CC86D733 DBE7BF38 154B36CF 8A96D156 7899AAAE 0C09D4C8 B6B7B86F D2A1EA1D E62FF864 3EC7C271 82797722 5E6AC2F0 BD61C746 961542A3 CE3BEA5D B54FE70E 63E6D09F 8FC28658 E80567A4 7CFDE60E E741E5D8 5A7BD469 31CED822 03655949 64B83989 6FCAABCC C9B31959 C083F22A D3EE591C 32FAB2C7 448F2A05 7DB2DB49 EE52E018 2741E538 65F004CC 8E704B7C 5C40BF30 4C4D8C4F 13EDF604 7C555302 D2238D8C E11DF242 4F1B66C2 C5D238D0 744DB679 AF289048 7031F9C0 AEA1C4BB 6FE9554E E528FDF1 B05E5B25 6223B2F0 9215F371 9F9C7CCC 69DDF172 D0D62342 17FCC003 7F18B93E F5389130 B7A661E5 C26E5421 4068BBCA FEA32A67 818BD307 5AD1F5C7 E9CC3D17 37FB2817 1BAF84DB B6612B78 81C1A48E 439CD03A 92BF5222 5A2B38E6 542E9F72 2BCE15A3 81B5753E A8427633 81CCAE83 512B3051 1B32E5E8 D8036214 9AD030AA BA5F3A57 98BB22AA 7EC1B6D0 F17903F4 E234EA60 34AA8597 3F79A93F FB82A75C 47C03D43 D2F9CA02 D03199BA CEDDD453 34DBC6B5 FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF The hexadecimal representation of the cofactor \\(r = \\frac{p\u22121}{q}\\) is as follows. 1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 000000BC 93C467E3 7DB0C7A4 D1BE3F81 0152CB56 A1CECC3A F65CC019 0C03DF34 709B8AF6 A64C0CED CF2D559D A9D97F09 5C3076C6 86037619 148D2C86 C317102A FA214803 1F04440A C0FF0C9A 417A8921 2512E760 7B2501DA A4D38A2C 1410C483 6149E2BD B8C8260E 627C4646 963EFFE9 E16E495D 48BD215C 6D8EC9D1 667657A2 A1C8506F 2113FFAD 19A6B2BC 7C457604 56719183 309F874B C9ACE570 FFDA877A A2B23A2D 6F291C15 54CA2EB1 2F12CD00 9B8B8734 A64AD51E B893BD89 1750B851 62241D90 8F0C9709 879758E7 E8233EAB 3BF2D6AB 53AFA32A A153AD66 82E5A064 8897C9BE 18A0D50B ECE030C3 432336AD 9163E33F 8E7DAF49 8F14BB28 52AFFA81 4841EB18 DD5F0E89 516D5577 76285C16 071D2111 94EE1C3F 34642036 AB886E3E C28882CE 4003DEA3 35B4D935 BAE4B582 35B9FB2B AB713C8F 705A1C7D E4222020 9D6BBCAC C4673186 01565272 E4A63E38 E2499754 AE493AC1 A8E83469 EEF35CA2 7C271BC7 92EEE211 56E617B9 22EA8F71 3C22CF28 2DC5D638 5BB12868 EB781278 FA0AB2A8 958FCCB5 FFE2E5C3 61FC1744 20122B01 63CA4A46 308C8C46 C91EA745 7C1AD0D6 9FD4A7F5 29FD4A7F 529FD4A7 F529FD4A 7F529FD4 A7F529FD 4A7F529F D4A7F52A Finally, the generator \\(g\\) is chosen to be \\(g = 2^r\\bmod p\\) and has the following hexadecimal representation. 037DE384 F98F6E03 8D2A3141 825B33D5 D45EC4CC 64CFD15E 750D6798 F5196CF2 A142CDF3 3F6EF853 840EC7D4 EC804794 CFB0CFB6 5363B256 6387B98E E0E3DEF1 B706FA55 D5038FFB 4A62DCBB 93B1DDD8 D3B308DA 86D1C3A5 25EF356F E5BB5931 4E656334 80B396E1 DD4B795F 78DE07D8 6B0E2A05 BE6AF78F D7F736FC BA6C032E 26E050AF 50A03C65 FA7B6C87 F4554CB5 7F3DABCB AD8EB9D8 FDEBEEF5 8570669A CC3EDA17 DBFC47B8 B3C39AA0 8B829B28 872E62B5 D1B13A98 F09D40AC 20C2AB74 A6750E7C 8750B514 1E221C41 F55BBA31 D8E41422 B64D2CBA 7AAA0E9F D8785702 F6932825 BF45DE83 86D24900 742062C1 322B37C5 0AF18215 8090C35D A9355E6C F7F72DA3 9A2284FD FB1918B2 A2A30E69 501FA234 2B728263 DF23F1DB 8355BDE1 EB276FB3 685F3716 72CEB313 FDAB069C C9B11AB6 C59BCE62 BAAD96AA C96B0DBE 0C7E71FC B2255254 5A5D1CED EEE01E4B C0CDBDB7 6B6AD45F 09AF5E71 114A005F 93AD97B8 FE09274E 76C94B20 08926B38 CAEC94C9 5E96D628 F6BC8066 2BA06207 801328B2 C6A60526 BF7CD02D 9661385A C3B1CBDB 50F759D0 E9F61C11 A07BF421 8F299BCB 29005200 76EBD2D9 5A3DEE96 D4809EF3 4ABEB83F DBA8A12C 5CA82757 288A89C9 31CF564F 00E8A317 AE1E1D82 8E61369B A0DDBADB 10C136F8 691101AD 82DC5477 5AB83538 40D99921 97D80A6E 94B38AC4 17CDDF40 B0C73ABF 03E8E0AA Alternative parameter sets are possible. A good source for parameter generation is appendix A of FIPS \\(186-4\\) 2 . However, allowing alternate parameters would force election verifiers to recognize and check that parameters are correctly generated. Since these checks would be very different from other checks that are required of a verifier, allowing alternate parameters would add substantial complexity to election verifiers. For this reason, this version of ElectionGuard fixes the parameters as above. An ElectionGuard version 1 election verifier may assume that the baseline parameters match the parameters provided above. However, it is recommended that the above parameters be checked against the parameters of each election to accommodate the possibility of different parameters in future versions of ElectionGuard. 3 Discovering this value \\(\\delta\\) required a search through roughly 42 million values satisfying the first three of the above properties to find one for which both \\(p\\) and \\(\\frac{p-1}{2q}\\) are both prime. \u21a9 NIST (2013) Digital Signature Standard (DSS). In: FIPS 186-4. https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf \u21a9 If alternative parameters are allowed, election verifiers must confir that \\(p, q, r\\) and \\(g\\) are such that both \\(p\\) and \\(q\\) are prime (this may be done probabilistically using the Miller-Rabin algorithm), that \\(p-1 = qr\\) is satisfied, that \\(q\\) is not a divisor of \\(r\\) , that \\(1<g<p\\) , that \\(g^qq \\bmod p = 1\\) , and that generation of parameters is consistent with the sited standard. \u21a9","title":"Baseline Parameters"},{"location":"spec/0.95.0/6_Ballot_Encryption/","text":"Ballot Encryption An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). To enable homomorphic addition (for tallying), these values are exponentiated during encryption. Specifically, to encrypt a ballot entry \\((V)\\) , a random value \\(R\\) is selected such that \\(0 \u2264 R < q\\) , and the following computation is performed. Zero (not selected) is encrypted as \\((g^R \\bmod p,K^R \\bmod p)\\) . One (selected) is encrypted as \\((g^R \\bmod p, g \u22c5 K^R \\bmod p)\\) . Note that if multiple encrypted votes \\((g^{R_i} \\bmod p, g^{V_i} \u22c5 K^{R_i} \\bmod p)\\) are formed, their component-wise product \\((g^{\\sum_iR_i} \\bmod p, g^{\\sum_iV_i} \u22c5 K^{\\sum_iR_i} \\bmod p)\\) serves as an encryption of \\(\\sum_iV_i \u2013\\) which is the tally of those votes. 1 A contest in an election consists of a set of options together with a selection limit that indicates the number of selections that are allowed to be made in that contest. In most elections, most contests have a selection limit of one. However, a larger selection limit (e.g., select up to three) is not uncommon in some elections. Approval voting can be achieved by setting the selection limit to the total number of options in a contest. Ranked choice voting is not supported in this version of ElectionGuard, but it may be enabled in a future version. 2 Also, write-ins are assumed to be explicitly registered or allowed to be lumped into a single \u201cwrite-ins\u201d category for the purpose of verifiable tallying. Verifiable tallying of free-form write-ins may be best done with a MixNet 3 design. A legitimate vote in a contest consists of a set of selections with cardinality not exceeding the selection limit of that contest. To accommodate legitimate undervotes, the internal representation of a contest is augmented with \u201cplaceholder\u201d options equal in number to the selection limit. Placeholder options are selected as necessary to force the total number of selections made in a contest to be equal to the selection limit. When the selection limit is one, for example, the single placeholder option can be thought of as a \u201cnone of the above\u201d option. With larger selection limits, the number of placeholder options selected corresponds to the number of additional options that a voter could have selected in a contest. Note For efficiency, the placeholder options could be eliminated in an approval vote. However, to simplify the construction of election verifiers, we presume that placeholder options are always present \u2013 even for approval votes. Two things must now be proven about the encryption of each vote to ensure the integrity of a ballot. The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in each contest is equal to the selection limit for that contest (usually one). The use of ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. ChaumPedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013 particularly that a value is an encryption of either zero or one. The encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit \u2013 again using a Chaum-Pedersen proof. Note Note that the decryption of the selection limit could be more efficiently demonstrated by just releasing the sum of the nonces used for each of the individual encryptions. But, again to simplify the construction of election verifiers, a Chaum-Pedersen proof is used here as well. The \u201crandom\u201d nonces used for the ElGamal encryption of the ballot nonces are derived from a single 256-bit master nonce \\(R_B\\) for each ballot. For each contest listed in the ballot coding file, a contest nonce \\(R_C\\) is derived from the master nonce \\((R_B)\\) and the contest label \\((L_C)\\) as \\(R_C = H(L_C,R_B)\\) using the hash function SHA-256. For each option listed in the ballot coding file, the nonce used to encrypt that option is derived from the contest nonce \\((R_C)\\) and the selection label for that option \\((L_S)\\) as \\(R = H(L_S, R_C)\\) . A user of ElectionGuard may optionally provide an additional public key. If such a key is provided, ElectionGuard uses that key to encrypt each ballot\u2019s master nonce \\(R_B\\) and return this encryption together with the encrypted ballot. Ballot nonces may be independent across different ballots, and only the nonces used to encrypt ballot selections need to be derived from the master nonce. The use of a single master nonce for each ballot allows the entire ballot encryption to be re-derived from the contents of a ballot and the master nonce. It also allows the encrypted ballot to be fully decrypted with the single master nonce. Outline for proofs of ballot correctness To prove that an ElGamal encryption pair \\((\\alpha, \\beta)\\) is an encryption of zero, the Chaum-Pedersen protocol proceeds as follows. NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero (given knowledge of encryption nonce \\(R\\) ) The prover selects a random value \\(u\\) in \\(\u2124_q\\) and commits to the pair \\((a, b) =(g^u \\bmod p,K^u \\bmod p)\\) . A hash computation is then performed (using the Fiat-Shamir heuristic) to create a pseudo-random challenge value \\(c = H(\\bar{Q}, (\\alpha, \\beta), (a, b))\\) , and the prover responds with \\(v = (u + cR) \\bmod q\\) . A verifier can now confirm the claim by checking that both \\(g^v\\bmod p = a\u22c5\\alpha^c\\bmod p\\) and \\(K^v \\bmod p = b\u22c5\\beta^c \\bmod p\\) are true. NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of one (given knowledge of encryption nonce \\(R\\) ) To prove that \\((\\alpha, \\beta)\\) is an encryption of one, \\(\\frac \\beta g \\bmod p\\) is substituted for \\(\\beta\\) in the above. The verifier can be relieved of the need to perform a modular division by computing \\(\\beta \\bar{g} \\bmod p\\) rather than \\(\\frac \\beta g \\bmod p\\) . As an alternative, the verifier can confirm that \\(g^c \u22c5 K^v \\bmod p = b \u22c5 \\beta^c \\bmod p\\) instead of \\(K^{v} \\bmod p = b \u22c5 (\\frac \\beta g)^c \\bmod p\\) . As with many zero-knowledge protocols, if the prover knows a challenge value prior to making its commitment, it can create a false proof. For example, if a challenge \\(c\\) is known to be forthcoming, a prover can generate a random \\(v\\) in \\(\u2124_q\\) and commit to \\((a, b) = (\\frac {g^v} {\\alpha^c} \\bmod p, \\frac {K^v} {\\beta^c} \\bmod p) = (g^{v} \\alpha^{q\u2212c} \\bmod p, K^v \\beta^{q\u2212c} \\bmod p)\\) . This selection will satisfy the required checks for \\((\\alpha, \\beta)\\) to appear as an encryption of zero regardless of the values of \\((\\alpha, \\beta)\\) . Similarly, setting \\((a, b) = (\\frac {g^v} {\\alpha^c} \\bmod p, \\frac {K^vg^c} {\\beta^c} \\bmod p) = (g^{v} \\alpha^{q\u2212c} \\bmod p, K^v g^c\\beta^{q\u2212c} \\bmod p)\\) will satisfy the required checks for \\((\\alpha, \\beta)\\) to appear as an encryption of one regardless of the values of \\((\\alpha, \\beta)\\) . This quirk is what enables the Cramer-Damg\u00e5rd-Schoenmakers technique to prove a disjunction of two predicates. Sketch of NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero or one After the prover makes commitments \\((a_0, b_0)\\) and \\((a_1, b_1)\\) to the respective assertions that \\((\\alpha, \\beta)\\) is an encryption of zero and \\((\\alpha, \\beta)\\) is an encryption of one, a single challenge value \\(c\\) is selected by hashing all commitments and baseline parameters. The prover must then provide challenge values \\(c_0\\) and \\(c_1\\) such that \\(c = c_0 + c_1 \\bmod q\\) . Since the prover has complete freedom to choose one of \\(c_0\\) and \\(c_1\\) , the prover can fix one value in advance \u2013 either \\(c_0\\) if \\((\\alpha, \\beta)\\) is actually an encryption of one or \\(c_1\\) if \\((\\alpha, \\beta)\\) is actually an encryption of zero. In response to the resulting challenge \\(c\\) , the prover uses this freedom to answer its faux claim with its chosen challenge value and then uses the remaining challenge value (as forced by the constraint that \\(c = (c_0 + c_1) \\bmod q\\) ) to demonstrate the truth of the other claim. An observer can see that one of the two claims must be true but cannot tell which. Details for proofs of ballot correctness The full protocol proceeds as follows \u2013 fully divided into the two cases. To encrypt an \u201cunselected\u201d option on a ballot, a random nonce \\(R\\) is selected uniformly \\(\u2124_q\\) and an encryption of zero is formed as \\((\\alpha, \\beta) = (g^R \\bmod p,K^R \\bmod p)\\) . NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero or one (given knowledge of encryption nonce \\(R\\) for which \\((\\alpha, \\beta)\\) is an encryption of zero ) To create the proof that \\((\\alpha, \\beta)\\) is an encryption of a zero or a one, randomly select \\(c_1\\) , \\(v_1\\) , and \\(u_0\\) from \\(\u2124_q\\) and form the commitments \\[ (a_0, b_0) = (g^{u_0} \\bmod p,K^{u_0} \\bmod p) \\] and \\[ (a_1, b_1) = (\\frac {g^{v_1}} {\\alpha^{c_1}} \\bmod p, \\frac {K^{v_1}g^{c_1}} {\\beta^{c_1}} \\bmod p) = (g^{v_1}\\alpha^{q-c_1} \\bmod p, K^{v_1}g^{c_1}\\beta^{q-c_1}\\bmod p). \\] A challenge value \\(c\\) is formed by hashing the extended base hash \\(\\bar{Q}\\) together with \\((\\alpha, \\beta)\\) , \\((a_0, b_0)\\) , and \\((a_1, b_1)\\) to form a challenge value \\(c = H(Q, (\\alpha, \\beta), (a_0, b_0), (a_1, b_1))\\) . The proof is completed by forming \\(c_0 = (c \u2212 c_1) \\bmod q\\) and \\(v_0 = (u_0 + c_0 \u22c5 R) \\bmod q\\) and answering the challenge by returning \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . To encrypt a \u201cselected\u201d option on a ballot, a random nonce \\(R\\) is selected uniformly from \\(\u2124_q\\) and an encryption of one is formed as \\((\\alpha, \\beta) = (g^r \\bmod p, g \u22c5 K^r\\bmod p)\\) . NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero or one (given knowledge of encryption nonce \\(R\\) for which \\((\\alpha, \\beta)\\) is an encryption of one ) To create the proof that \\((\\alpha, \\beta)\\) is an encryption of a zero or a one, randomly select \\(c_0\\) , \\(v_0\\) , and \\(u_1\\) from \\(\u2124_q\\) and form the commitments \\[ (a_0, b_0) = (\\frac{g^{v_0}}{\\alpha^{c_0}} \\bmod p, \\frac{K^{v_0}}{\\beta^{c_0}}\\bmod p) = (g^{v_0}\\alpha^{q-c_0}\\bmod p, K^{v_0}\\beta^{q-c_0}\\bmod p) \\] and \\[ (a_1,b_1)=(g^{u_1} \\bmod p,K^{u_1}\\bmod p) \\] A challenge value \\(c\\) is formed by hashing the extended base hash \\(\\bar{Q}\\) together with \\((\\alpha, \\beta)\\) , \\((a_0, b_0)\\) , and \\((a_1, b_1)\\) to form a challenge value \\(c = H(\\bar{Q}, (\\alpha, \\beta), (a_0, b_0), (a_1, b_1))\\) . The proof is completed by forming \\(c_1 = (c \u2212 c_0) \\bmod q\\) and \\(v_1 = (u_1 + c_1 \u22c5 R) \\bmod q\\) and answering the challenge by returning \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . In either of the two above cases, what is published in the election record is the encryption \\((\\alpha, \\beta)\\) together with the commitments \\((a_0, b_0)\\) and \\((a_1, b_1)\\) which are all hashed together with the election\u2019s extended base hash to form the challenge value \\(c\\) which is published together with values \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . Important An election verifier must confirm the following for each possible selection on a ballot: (A) The given values \\(\\alpha\\) , \\(\\beta\\) , \\(a_0\\) , \\(b_0\\) , \\(a_1\\) , and \\(b_1\\) are all in the set \\(\u2124_p^r\\) . (A value \\(x\\) is in \\(\u2124_p^r\\) if and only if \\(x\\) is an integer such that 0 \u2264 \\(x\\) < \\(p\\) and \\(x^q \\bmod p = 1\\) is satisfied.) (B) The challenge \\(c\\) is correctly computed as \\(c = H(\\bar{Q}, (\\alpha,\\beta), (a_0, b_0), (a_1, b_1))\\) . (C) The given values \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) are each in the set \\(\u2124_q\\) . (A value \\(x\\) is in \\(\u2124_q\\) if and only if \\(x\\) is an integer such that \\(0 \u2264 x < q\\) .) (D) The equation \\(c = (c_0 + c_1) \\bmod q\\) is satisfied. (E) The equation \\(g^{v_0} \\bmod p = a_0\\alpha^{c_0} \\bmod p\\) is satisfied. (F) The equation \\(g^{v_1} \\bmod p = a_1\\alpha^{c_1} \\bmod p\\) is satisfied. (G) The equation \\(K^{v_0} \\bmod p = b_0\\beta^{c_0} \\bmod p\\) is satisfied. (H) The equation \\(g^{c_1}K^{v_1} \\bmod p = b_1\\beta^{c_1} \\bmod p\\) is satisfied. Proof of satisfying the selection limit The final step in proving that a ballot is well-formed is demonstrating that the selection limits for each contest have not been exceeded. This is accomplished by homomorphically combining all of the \\((\\alpha_i, \\beta_i)\\) values for a contest by forming the aggregate contest encryption \\((\\alpha, \\beta) = (\\Pi_i\\alpha_i \\bmod p , \\Pi_i\\beta_i \\bmod p)\\) and proving that \\((\\alpha, \\beta)\\) is an encryption of the total number of votes allowed for that contest (usually one). The simplest way to complete this proof is to combine all of the random nonces \\(R_i\\) that were used to form each \\((\\alpha_i,\\beta_i) = (g^{R_i} \\bmod p, K^{R_i} \\bmod p)\\) or \\((\\alpha_i,\\beta_i) = (g^{R_i} \\bmod p, g \u22c5 K^{R_i} \\bmod p)\\) \u2013 depending on whether the value encrypted is zero or one. The aggregate nonce \\(R = \\sum_iR_i \\bmod q\\) matches the aggregate contest encryption as \\((\\alpha, \\beta) = (\\Pi_i\\alpha_i \\bmod p, \\Pi_i\\beta_i \\bmod p) = (g^R \\bmod p,g^LK^R \\bmod p)\\) - where \\(L\\) is the selection limit for the contest. (Recall that \\(L\\) extra \u201cplaceholder\u201d positions will be added to each contest and set to one as necessary to ensure that exactly \\(L\\) selections are made for the contest.) NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of \\(L\\) (given knowledge of aggregate encryption nonce \\(R\\) ) An additional Chaum-Pedersen proof of \\((\\alpha,\\beta)\\) being an encryption of \\(L\\) is performed by selecting a random \\(U\\) in \\(\u2124_q\\) , publishing \\((a,b) = (g^U \\bmod p,K^U \\bmod p)\\) , hashing these values together with election\u2019s extended base hash \\(\\bar{Q}\\) to form a pseudo-random challenge \\(C = H(\\bar{Q}, (\\alpha, \\beta), (a, b))\\) , and responding by publishing \\(V = (U + CR) \\bmod q\\) . 4 Note that all of the above proofs can be performed directly by the entity performing the public key encryption of a ballot without access to the decryption key(s). All that is required is the nonces \\(R_i\\) used for the individual selection encryptions. Important An election verifier must confirm the following for each contest on the ballot: (A) The number of placeholder positions matches the contest\u2019s selection limit \\(L\\) . (B) The contest total \\((A, B)\\) satisfies \\(A = \\Pi_i\\alpha_i \\bmod p\\) and \\(B = \\Pi_i\\beta_i \\bmod p\\) where the \\((\\alpha_i, \\beta_i)\\) represent all possible selections (including placeholder selections) for the contest. (C) The given value \\(V\\) is in \\(\u2124_q\\) . (D) The given values \\(a\\) and \\(b\\) are each in \\(\u2124_q^r\\) . (E) The challenge value \\(C\\) is correctly computed as \\(C = H(\\bar{Q}, (A, B), (a, b))\\) . (F) The equation \\(g^V \\bmod p = (aA^C) \\bmod p\\) is satisfied. (G) The equation \\((g^{LC}K^V) \\bmod p = (bB^C) \\bmod p\\) is satisfied. Tracking codes Upon completion of the encryption of each ballot, a tracking code is prepared for each voter. The code is a running hash that begins with the extended base hash code \\(\\bar{Q}\\) and includes an identifier for the voting device, the location of the voting device, the date and time that the ballot was encrypted, and, of course, the encryption of the ballot itself. The hash \\((H)\\) used for this purpose is SHA-256. The tracking code is formed as follows. \\(H_0 = H(\\bar{Q})\\) where \\(\\bar{Q}\\) is the extended base hash code of the election. For ballot with index \\(i > 0, H_i = H(H_{i\u22121},D, T, B_i)\\) where \\(D\\) consists of the voting device information described above, \\(T\\) is the date and time of ballot encryption, and \\(B_i\\) is an ordered list of the individual encryptions on the ballot \u2013 with the ordering as specified by the ballot coding file. At the conclusion of a voting period (this may be the end of a day in a multi-day election), the hash chain is closed by computing \\(\\bar{H} = H(H_\u2113,\\) \"CLOSE\" \\()\\) , where \\(H_\u2113\\) is the final tracking code produced by that device during that voting period. The close of the hash chain can be computed either by the voting device or subsequently by election administrators, and it is published as part of the election record. Important An election verifier must confirm that each of the values in the running hash is correctly computed. Specifically, an election verifier must confirm each of the following. (A) The equation \\(H_0 = H(\\bar{Q})\\) is satisfied. (B) For each ballot \\(B_i,H_i = H(H_{i-1},D,T,B_i)\\) is satisfied. (C) The closing hash \\(\\bar{H} = H(H_\u2113,\\) \"CLOSE\" \\()\\) is correctly computed from the final tracking code \\(H_\u2113\\) . Once in possession of a tracking code (and never before), a voter is afforded an option to either cast the associated ballot or spoil it and restart the ballot preparation process. The precise mechanism for voters to make these selections may vary depending upon the instantiation, but this choice would ordinarily be made immediately after a voter is presented with the tracking code, and the status of the ballot would be undetermined until the decision is made. It is possible, for instance, for a voter to make the decision directly on the voting device, or a voter may instead be afforded an option to deposit the ballot in a receptacle or to take it to a poll worker to be spoiled. For vote-by-mail scenarios, a voter can be sent (hashes of) two complete sets of encryptions for each selectable option and can effect a ballot challenge implicitly by choosing which encryptions to return. The initial decryption actually forms the value \\(g^{\\sum_iV_i}\\bmod p\\) . However, since \\(\\sum_iV_i\\) is a relatively small value, it can be effectively computed from \\(g^{\\sum_iV_i}\\bmod p\\) by means of an exhaustive search or similar methods. \u21a9 Benaloh J., Moran. T, Naish L., Ramchen K., and Teague V. Shuffle-Sum: Coercion-Resistant Verifiable Tallying for STV Voting (2009) in Transactions of Information Forensics and Security. \u21a9 Chaum D. Untraceable Electronic Mail, Return Addresses, and Digital Pseudonyms (1981) Communications of the ACM. \u21a9 One could simply release the aggregate nonce \\(R = \\sum_iR_i \\bmod q\\) to complete this proof. However, since Chaum-Pedersen proofs are being performed elsewhere, it is simpler for a verifier to just repeat the same steps. \u21a9","title":"Ballot Encryption"},{"location":"spec/0.95.0/6_Ballot_Encryption/#ballot-encryption","text":"An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). To enable homomorphic addition (for tallying), these values are exponentiated during encryption. Specifically, to encrypt a ballot entry \\((V)\\) , a random value \\(R\\) is selected such that \\(0 \u2264 R < q\\) , and the following computation is performed. Zero (not selected) is encrypted as \\((g^R \\bmod p,K^R \\bmod p)\\) . One (selected) is encrypted as \\((g^R \\bmod p, g \u22c5 K^R \\bmod p)\\) . Note that if multiple encrypted votes \\((g^{R_i} \\bmod p, g^{V_i} \u22c5 K^{R_i} \\bmod p)\\) are formed, their component-wise product \\((g^{\\sum_iR_i} \\bmod p, g^{\\sum_iV_i} \u22c5 K^{\\sum_iR_i} \\bmod p)\\) serves as an encryption of \\(\\sum_iV_i \u2013\\) which is the tally of those votes. 1 A contest in an election consists of a set of options together with a selection limit that indicates the number of selections that are allowed to be made in that contest. In most elections, most contests have a selection limit of one. However, a larger selection limit (e.g., select up to three) is not uncommon in some elections. Approval voting can be achieved by setting the selection limit to the total number of options in a contest. Ranked choice voting is not supported in this version of ElectionGuard, but it may be enabled in a future version. 2 Also, write-ins are assumed to be explicitly registered or allowed to be lumped into a single \u201cwrite-ins\u201d category for the purpose of verifiable tallying. Verifiable tallying of free-form write-ins may be best done with a MixNet 3 design. A legitimate vote in a contest consists of a set of selections with cardinality not exceeding the selection limit of that contest. To accommodate legitimate undervotes, the internal representation of a contest is augmented with \u201cplaceholder\u201d options equal in number to the selection limit. Placeholder options are selected as necessary to force the total number of selections made in a contest to be equal to the selection limit. When the selection limit is one, for example, the single placeholder option can be thought of as a \u201cnone of the above\u201d option. With larger selection limits, the number of placeholder options selected corresponds to the number of additional options that a voter could have selected in a contest. Note For efficiency, the placeholder options could be eliminated in an approval vote. However, to simplify the construction of election verifiers, we presume that placeholder options are always present \u2013 even for approval votes. Two things must now be proven about the encryption of each vote to ensure the integrity of a ballot. The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in each contest is equal to the selection limit for that contest (usually one). The use of ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. ChaumPedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013 particularly that a value is an encryption of either zero or one. The encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit \u2013 again using a Chaum-Pedersen proof. Note Note that the decryption of the selection limit could be more efficiently demonstrated by just releasing the sum of the nonces used for each of the individual encryptions. But, again to simplify the construction of election verifiers, a Chaum-Pedersen proof is used here as well. The \u201crandom\u201d nonces used for the ElGamal encryption of the ballot nonces are derived from a single 256-bit master nonce \\(R_B\\) for each ballot. For each contest listed in the ballot coding file, a contest nonce \\(R_C\\) is derived from the master nonce \\((R_B)\\) and the contest label \\((L_C)\\) as \\(R_C = H(L_C,R_B)\\) using the hash function SHA-256. For each option listed in the ballot coding file, the nonce used to encrypt that option is derived from the contest nonce \\((R_C)\\) and the selection label for that option \\((L_S)\\) as \\(R = H(L_S, R_C)\\) . A user of ElectionGuard may optionally provide an additional public key. If such a key is provided, ElectionGuard uses that key to encrypt each ballot\u2019s master nonce \\(R_B\\) and return this encryption together with the encrypted ballot. Ballot nonces may be independent across different ballots, and only the nonces used to encrypt ballot selections need to be derived from the master nonce. The use of a single master nonce for each ballot allows the entire ballot encryption to be re-derived from the contents of a ballot and the master nonce. It also allows the encrypted ballot to be fully decrypted with the single master nonce.","title":"Ballot Encryption"},{"location":"spec/0.95.0/6_Ballot_Encryption/#outline-for-proofs-of-ballot-correctness","text":"To prove that an ElGamal encryption pair \\((\\alpha, \\beta)\\) is an encryption of zero, the Chaum-Pedersen protocol proceeds as follows. NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero (given knowledge of encryption nonce \\(R\\) ) The prover selects a random value \\(u\\) in \\(\u2124_q\\) and commits to the pair \\((a, b) =(g^u \\bmod p,K^u \\bmod p)\\) . A hash computation is then performed (using the Fiat-Shamir heuristic) to create a pseudo-random challenge value \\(c = H(\\bar{Q}, (\\alpha, \\beta), (a, b))\\) , and the prover responds with \\(v = (u + cR) \\bmod q\\) . A verifier can now confirm the claim by checking that both \\(g^v\\bmod p = a\u22c5\\alpha^c\\bmod p\\) and \\(K^v \\bmod p = b\u22c5\\beta^c \\bmod p\\) are true. NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of one (given knowledge of encryption nonce \\(R\\) ) To prove that \\((\\alpha, \\beta)\\) is an encryption of one, \\(\\frac \\beta g \\bmod p\\) is substituted for \\(\\beta\\) in the above. The verifier can be relieved of the need to perform a modular division by computing \\(\\beta \\bar{g} \\bmod p\\) rather than \\(\\frac \\beta g \\bmod p\\) . As an alternative, the verifier can confirm that \\(g^c \u22c5 K^v \\bmod p = b \u22c5 \\beta^c \\bmod p\\) instead of \\(K^{v} \\bmod p = b \u22c5 (\\frac \\beta g)^c \\bmod p\\) . As with many zero-knowledge protocols, if the prover knows a challenge value prior to making its commitment, it can create a false proof. For example, if a challenge \\(c\\) is known to be forthcoming, a prover can generate a random \\(v\\) in \\(\u2124_q\\) and commit to \\((a, b) = (\\frac {g^v} {\\alpha^c} \\bmod p, \\frac {K^v} {\\beta^c} \\bmod p) = (g^{v} \\alpha^{q\u2212c} \\bmod p, K^v \\beta^{q\u2212c} \\bmod p)\\) . This selection will satisfy the required checks for \\((\\alpha, \\beta)\\) to appear as an encryption of zero regardless of the values of \\((\\alpha, \\beta)\\) . Similarly, setting \\((a, b) = (\\frac {g^v} {\\alpha^c} \\bmod p, \\frac {K^vg^c} {\\beta^c} \\bmod p) = (g^{v} \\alpha^{q\u2212c} \\bmod p, K^v g^c\\beta^{q\u2212c} \\bmod p)\\) will satisfy the required checks for \\((\\alpha, \\beta)\\) to appear as an encryption of one regardless of the values of \\((\\alpha, \\beta)\\) . This quirk is what enables the Cramer-Damg\u00e5rd-Schoenmakers technique to prove a disjunction of two predicates. Sketch of NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero or one After the prover makes commitments \\((a_0, b_0)\\) and \\((a_1, b_1)\\) to the respective assertions that \\((\\alpha, \\beta)\\) is an encryption of zero and \\((\\alpha, \\beta)\\) is an encryption of one, a single challenge value \\(c\\) is selected by hashing all commitments and baseline parameters. The prover must then provide challenge values \\(c_0\\) and \\(c_1\\) such that \\(c = c_0 + c_1 \\bmod q\\) . Since the prover has complete freedom to choose one of \\(c_0\\) and \\(c_1\\) , the prover can fix one value in advance \u2013 either \\(c_0\\) if \\((\\alpha, \\beta)\\) is actually an encryption of one or \\(c_1\\) if \\((\\alpha, \\beta)\\) is actually an encryption of zero. In response to the resulting challenge \\(c\\) , the prover uses this freedom to answer its faux claim with its chosen challenge value and then uses the remaining challenge value (as forced by the constraint that \\(c = (c_0 + c_1) \\bmod q\\) ) to demonstrate the truth of the other claim. An observer can see that one of the two claims must be true but cannot tell which.","title":"Outline for proofs of ballot correctness"},{"location":"spec/0.95.0/6_Ballot_Encryption/#details-for-proofs-of-ballot-correctness","text":"The full protocol proceeds as follows \u2013 fully divided into the two cases. To encrypt an \u201cunselected\u201d option on a ballot, a random nonce \\(R\\) is selected uniformly \\(\u2124_q\\) and an encryption of zero is formed as \\((\\alpha, \\beta) = (g^R \\bmod p,K^R \\bmod p)\\) . NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero or one (given knowledge of encryption nonce \\(R\\) for which \\((\\alpha, \\beta)\\) is an encryption of zero ) To create the proof that \\((\\alpha, \\beta)\\) is an encryption of a zero or a one, randomly select \\(c_1\\) , \\(v_1\\) , and \\(u_0\\) from \\(\u2124_q\\) and form the commitments \\[ (a_0, b_0) = (g^{u_0} \\bmod p,K^{u_0} \\bmod p) \\] and \\[ (a_1, b_1) = (\\frac {g^{v_1}} {\\alpha^{c_1}} \\bmod p, \\frac {K^{v_1}g^{c_1}} {\\beta^{c_1}} \\bmod p) = (g^{v_1}\\alpha^{q-c_1} \\bmod p, K^{v_1}g^{c_1}\\beta^{q-c_1}\\bmod p). \\] A challenge value \\(c\\) is formed by hashing the extended base hash \\(\\bar{Q}\\) together with \\((\\alpha, \\beta)\\) , \\((a_0, b_0)\\) , and \\((a_1, b_1)\\) to form a challenge value \\(c = H(Q, (\\alpha, \\beta), (a_0, b_0), (a_1, b_1))\\) . The proof is completed by forming \\(c_0 = (c \u2212 c_1) \\bmod q\\) and \\(v_0 = (u_0 + c_0 \u22c5 R) \\bmod q\\) and answering the challenge by returning \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . To encrypt a \u201cselected\u201d option on a ballot, a random nonce \\(R\\) is selected uniformly from \\(\u2124_q\\) and an encryption of one is formed as \\((\\alpha, \\beta) = (g^r \\bmod p, g \u22c5 K^r\\bmod p)\\) . NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero or one (given knowledge of encryption nonce \\(R\\) for which \\((\\alpha, \\beta)\\) is an encryption of one ) To create the proof that \\((\\alpha, \\beta)\\) is an encryption of a zero or a one, randomly select \\(c_0\\) , \\(v_0\\) , and \\(u_1\\) from \\(\u2124_q\\) and form the commitments \\[ (a_0, b_0) = (\\frac{g^{v_0}}{\\alpha^{c_0}} \\bmod p, \\frac{K^{v_0}}{\\beta^{c_0}}\\bmod p) = (g^{v_0}\\alpha^{q-c_0}\\bmod p, K^{v_0}\\beta^{q-c_0}\\bmod p) \\] and \\[ (a_1,b_1)=(g^{u_1} \\bmod p,K^{u_1}\\bmod p) \\] A challenge value \\(c\\) is formed by hashing the extended base hash \\(\\bar{Q}\\) together with \\((\\alpha, \\beta)\\) , \\((a_0, b_0)\\) , and \\((a_1, b_1)\\) to form a challenge value \\(c = H(\\bar{Q}, (\\alpha, \\beta), (a_0, b_0), (a_1, b_1))\\) . The proof is completed by forming \\(c_1 = (c \u2212 c_0) \\bmod q\\) and \\(v_1 = (u_1 + c_1 \u22c5 R) \\bmod q\\) and answering the challenge by returning \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . In either of the two above cases, what is published in the election record is the encryption \\((\\alpha, \\beta)\\) together with the commitments \\((a_0, b_0)\\) and \\((a_1, b_1)\\) which are all hashed together with the election\u2019s extended base hash to form the challenge value \\(c\\) which is published together with values \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . Important An election verifier must confirm the following for each possible selection on a ballot: (A) The given values \\(\\alpha\\) , \\(\\beta\\) , \\(a_0\\) , \\(b_0\\) , \\(a_1\\) , and \\(b_1\\) are all in the set \\(\u2124_p^r\\) . (A value \\(x\\) is in \\(\u2124_p^r\\) if and only if \\(x\\) is an integer such that 0 \u2264 \\(x\\) < \\(p\\) and \\(x^q \\bmod p = 1\\) is satisfied.) (B) The challenge \\(c\\) is correctly computed as \\(c = H(\\bar{Q}, (\\alpha,\\beta), (a_0, b_0), (a_1, b_1))\\) . (C) The given values \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) are each in the set \\(\u2124_q\\) . (A value \\(x\\) is in \\(\u2124_q\\) if and only if \\(x\\) is an integer such that \\(0 \u2264 x < q\\) .) (D) The equation \\(c = (c_0 + c_1) \\bmod q\\) is satisfied. (E) The equation \\(g^{v_0} \\bmod p = a_0\\alpha^{c_0} \\bmod p\\) is satisfied. (F) The equation \\(g^{v_1} \\bmod p = a_1\\alpha^{c_1} \\bmod p\\) is satisfied. (G) The equation \\(K^{v_0} \\bmod p = b_0\\beta^{c_0} \\bmod p\\) is satisfied. (H) The equation \\(g^{c_1}K^{v_1} \\bmod p = b_1\\beta^{c_1} \\bmod p\\) is satisfied.","title":"Details for proofs of ballot correctness"},{"location":"spec/0.95.0/6_Ballot_Encryption/#proof-of-satisfying-the-selection-limit","text":"The final step in proving that a ballot is well-formed is demonstrating that the selection limits for each contest have not been exceeded. This is accomplished by homomorphically combining all of the \\((\\alpha_i, \\beta_i)\\) values for a contest by forming the aggregate contest encryption \\((\\alpha, \\beta) = (\\Pi_i\\alpha_i \\bmod p , \\Pi_i\\beta_i \\bmod p)\\) and proving that \\((\\alpha, \\beta)\\) is an encryption of the total number of votes allowed for that contest (usually one). The simplest way to complete this proof is to combine all of the random nonces \\(R_i\\) that were used to form each \\((\\alpha_i,\\beta_i) = (g^{R_i} \\bmod p, K^{R_i} \\bmod p)\\) or \\((\\alpha_i,\\beta_i) = (g^{R_i} \\bmod p, g \u22c5 K^{R_i} \\bmod p)\\) \u2013 depending on whether the value encrypted is zero or one. The aggregate nonce \\(R = \\sum_iR_i \\bmod q\\) matches the aggregate contest encryption as \\((\\alpha, \\beta) = (\\Pi_i\\alpha_i \\bmod p, \\Pi_i\\beta_i \\bmod p) = (g^R \\bmod p,g^LK^R \\bmod p)\\) - where \\(L\\) is the selection limit for the contest. (Recall that \\(L\\) extra \u201cplaceholder\u201d positions will be added to each contest and set to one as necessary to ensure that exactly \\(L\\) selections are made for the contest.) NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of \\(L\\) (given knowledge of aggregate encryption nonce \\(R\\) ) An additional Chaum-Pedersen proof of \\((\\alpha,\\beta)\\) being an encryption of \\(L\\) is performed by selecting a random \\(U\\) in \\(\u2124_q\\) , publishing \\((a,b) = (g^U \\bmod p,K^U \\bmod p)\\) , hashing these values together with election\u2019s extended base hash \\(\\bar{Q}\\) to form a pseudo-random challenge \\(C = H(\\bar{Q}, (\\alpha, \\beta), (a, b))\\) , and responding by publishing \\(V = (U + CR) \\bmod q\\) . 4 Note that all of the above proofs can be performed directly by the entity performing the public key encryption of a ballot without access to the decryption key(s). All that is required is the nonces \\(R_i\\) used for the individual selection encryptions. Important An election verifier must confirm the following for each contest on the ballot: (A) The number of placeholder positions matches the contest\u2019s selection limit \\(L\\) . (B) The contest total \\((A, B)\\) satisfies \\(A = \\Pi_i\\alpha_i \\bmod p\\) and \\(B = \\Pi_i\\beta_i \\bmod p\\) where the \\((\\alpha_i, \\beta_i)\\) represent all possible selections (including placeholder selections) for the contest. (C) The given value \\(V\\) is in \\(\u2124_q\\) . (D) The given values \\(a\\) and \\(b\\) are each in \\(\u2124_q^r\\) . (E) The challenge value \\(C\\) is correctly computed as \\(C = H(\\bar{Q}, (A, B), (a, b))\\) . (F) The equation \\(g^V \\bmod p = (aA^C) \\bmod p\\) is satisfied. (G) The equation \\((g^{LC}K^V) \\bmod p = (bB^C) \\bmod p\\) is satisfied.","title":"Proof of satisfying the selection limit"},{"location":"spec/0.95.0/6_Ballot_Encryption/#tracking-codes","text":"Upon completion of the encryption of each ballot, a tracking code is prepared for each voter. The code is a running hash that begins with the extended base hash code \\(\\bar{Q}\\) and includes an identifier for the voting device, the location of the voting device, the date and time that the ballot was encrypted, and, of course, the encryption of the ballot itself. The hash \\((H)\\) used for this purpose is SHA-256. The tracking code is formed as follows. \\(H_0 = H(\\bar{Q})\\) where \\(\\bar{Q}\\) is the extended base hash code of the election. For ballot with index \\(i > 0, H_i = H(H_{i\u22121},D, T, B_i)\\) where \\(D\\) consists of the voting device information described above, \\(T\\) is the date and time of ballot encryption, and \\(B_i\\) is an ordered list of the individual encryptions on the ballot \u2013 with the ordering as specified by the ballot coding file. At the conclusion of a voting period (this may be the end of a day in a multi-day election), the hash chain is closed by computing \\(\\bar{H} = H(H_\u2113,\\) \"CLOSE\" \\()\\) , where \\(H_\u2113\\) is the final tracking code produced by that device during that voting period. The close of the hash chain can be computed either by the voting device or subsequently by election administrators, and it is published as part of the election record. Important An election verifier must confirm that each of the values in the running hash is correctly computed. Specifically, an election verifier must confirm each of the following. (A) The equation \\(H_0 = H(\\bar{Q})\\) is satisfied. (B) For each ballot \\(B_i,H_i = H(H_{i-1},D,T,B_i)\\) is satisfied. (C) The closing hash \\(\\bar{H} = H(H_\u2113,\\) \"CLOSE\" \\()\\) is correctly computed from the final tracking code \\(H_\u2113\\) . Once in possession of a tracking code (and never before), a voter is afforded an option to either cast the associated ballot or spoil it and restart the ballot preparation process. The precise mechanism for voters to make these selections may vary depending upon the instantiation, but this choice would ordinarily be made immediately after a voter is presented with the tracking code, and the status of the ballot would be undetermined until the decision is made. It is possible, for instance, for a voter to make the decision directly on the voting device, or a voter may instead be afforded an option to deposit the ballot in a receptacle or to take it to a poll worker to be spoiled. For vote-by-mail scenarios, a voter can be sent (hashes of) two complete sets of encryptions for each selectable option and can effect a ballot challenge implicitly by choosing which encryptions to return. The initial decryption actually forms the value \\(g^{\\sum_iV_i}\\bmod p\\) . However, since \\(\\sum_iV_i\\) is a relatively small value, it can be effectively computed from \\(g^{\\sum_iV_i}\\bmod p\\) by means of an exhaustive search or similar methods. \u21a9 Benaloh J., Moran. T, Naish L., Ramchen K., and Teague V. Shuffle-Sum: Coercion-Resistant Verifiable Tallying for STV Voting (2009) in Transactions of Information Forensics and Security. \u21a9 Chaum D. Untraceable Electronic Mail, Return Addresses, and Digital Pseudonyms (1981) Communications of the ACM. \u21a9 One could simply release the aggregate nonce \\(R = \\sum_iR_i \\bmod q\\) to complete this proof. However, since Chaum-Pedersen proofs are being performed elsewhere, it is simpler for a verifier to just repeat the same steps. \u21a9","title":"Tracking codes"},{"location":"spec/0.95.0/7_Ballot_Aggregation/","text":"Ballot Aggregation At the conclusion of voting, all of the ballot encryptions are published in the election record together with the proofs that the ballots are well-formed. Additionally, all of the encryptions of each option are homomorphically combined to form an encryption of the total number of times that option was selected. The encryptions \\(\\mathbf(\\alpha_{i},\\beta_{i})\\) of each individual option are combined by forming the product \\((A,B) = (\\Pi_{i}\\alpha_{i}\\bmod p,\\Pi_{i}\\beta_{i}\\bmod p)\\) . This aggregate encryption \\((A,B)\\) , which represents an encryption of the tally of that option, is published in the election record for each option. Important An election verifier must confirm for each (non-placeholder) option in each contest in the ballot coding file that the aggregate encryption \\((A,B)\\) satisfies \\(A = \\Pi_{j}\\alpha_{j}\\) and \\(B = \\Pi_{j}\\beta_{j}\\) where the \\((\\alpha_{j}, \\beta_{j})\\) are the corresponding encryptions on all cast ballots in the election record.","title":"Ballot Aggregation"},{"location":"spec/0.95.0/7_Ballot_Aggregation/#ballot-aggregation","text":"At the conclusion of voting, all of the ballot encryptions are published in the election record together with the proofs that the ballots are well-formed. Additionally, all of the encryptions of each option are homomorphically combined to form an encryption of the total number of times that option was selected. The encryptions \\(\\mathbf(\\alpha_{i},\\beta_{i})\\) of each individual option are combined by forming the product \\((A,B) = (\\Pi_{i}\\alpha_{i}\\bmod p,\\Pi_{i}\\beta_{i}\\bmod p)\\) . This aggregate encryption \\((A,B)\\) , which represents an encryption of the tally of that option, is published in the election record for each option. Important An election verifier must confirm for each (non-placeholder) option in each contest in the ballot coding file that the aggregate encryption \\((A,B)\\) satisfies \\(A = \\Pi_{j}\\alpha_{j}\\) and \\(B = \\Pi_{j}\\beta_{j}\\) where the \\((\\alpha_{j}, \\beta_{j})\\) are the corresponding encryptions on all cast ballots in the election record.","title":"Ballot Aggregation"},{"location":"spec/0.95.0/9_Election_Record/","text":"The Election Record The record of an election should be a full accounting of all of the election artifacts. Specifically, it should contain the following. Date and location of an election The ballot coding file The baseline parameters Primes \ud835\udc5d and \ud835\udc5e and integer \ud835\udc5f such that \ud835\udc5d=\ud835\udc5e\ud835\udc5f+1 and \ud835\udc5f is not a multiple of \ud835\udc5e A generator \ud835\udc54 of the order \ud835\udc5e multiplicative subgroup \u2124 * p The number \ud835\udc5b of election guardians The quorum threshold \ud835\udc58 of guardians required to complete verification The base hash value \ud835\udc44 computed from the above The commitments from each election guardian to each of their polynomial coefficients The proofs from each guardian of possession of each of the associated coefficients The election public key The extended base hash value \ud835\udc44 computed from the above Every encrypted ballot prepared in the election (whether cast or spoiled) All of the encrypted options on each ballot (including \u201cplaceholder\u201d options) The proofs that each such value is an encryption of either zero or one The selection limit for each contest The proof that the number of selections made matches the selection limit The device information for the device that encrypted the ballot The date and time of the ballot encryption The tracker code produced for the ballot The decryption of each spoiled ballot The selections made on the ballot The cleartext representation of the selections Partial decryptions by each guardian of each option Proofs of each partial decryption Shares of each missing partial decryption (if any) Proofs of shares of each missing partial decryption (if any) Lagrange coefficients used for replacement of any missing partial decryptions (if any) Tallies of each option in an election The encrypted tally of each option Full decryptions of each encrypted tally Cleartext representations of each tally Partial decryptions by each guardian of each tally Proofs of partial decryption of each tally Shares of each missing partial decryption (if any) Proofs of shares of each missing partial decryptio(if any) Lagrange coefficients used for replacement of any missing partial decryptions (if any) Ordered lists of the ballots encrypted by each device An election record should be digitally signed by election administrators together with the date of the signature. The entire election record and its digital signature should be published and made available for full download by any interested individuals. Tools should also be provided for easy look up of tracking codes by voters.","title":"Election Record"},{"location":"spec/0.95.0/9_Election_Record/#the-election-record","text":"The record of an election should be a full accounting of all of the election artifacts. Specifically, it should contain the following. Date and location of an election The ballot coding file The baseline parameters Primes \ud835\udc5d and \ud835\udc5e and integer \ud835\udc5f such that \ud835\udc5d=\ud835\udc5e\ud835\udc5f+1 and \ud835\udc5f is not a multiple of \ud835\udc5e A generator \ud835\udc54 of the order \ud835\udc5e multiplicative subgroup \u2124 * p The number \ud835\udc5b of election guardians The quorum threshold \ud835\udc58 of guardians required to complete verification The base hash value \ud835\udc44 computed from the above The commitments from each election guardian to each of their polynomial coefficients The proofs from each guardian of possession of each of the associated coefficients The election public key The extended base hash value \ud835\udc44 computed from the above Every encrypted ballot prepared in the election (whether cast or spoiled) All of the encrypted options on each ballot (including \u201cplaceholder\u201d options) The proofs that each such value is an encryption of either zero or one The selection limit for each contest The proof that the number of selections made matches the selection limit The device information for the device that encrypted the ballot The date and time of the ballot encryption The tracker code produced for the ballot The decryption of each spoiled ballot The selections made on the ballot The cleartext representation of the selections Partial decryptions by each guardian of each option Proofs of each partial decryption Shares of each missing partial decryption (if any) Proofs of shares of each missing partial decryption (if any) Lagrange coefficients used for replacement of any missing partial decryptions (if any) Tallies of each option in an election The encrypted tally of each option Full decryptions of each encrypted tally Cleartext representations of each tally Partial decryptions by each guardian of each tally Proofs of partial decryption of each tally Shares of each missing partial decryption (if any) Proofs of shares of each missing partial decryptio(if any) Lagrange coefficients used for replacement of any missing partial decryptions (if any) Ordered lists of the ballots encrypted by each device An election record should be digitally signed by election administrators together with the date of the signature. The entire election record and its digital signature should be published and made available for full download by any interested individuals. Tools should also be provided for easy look up of tracking codes by voters.","title":"The Election Record"},{"location":"spec/1.0.0/1_Overview/","text":"ElectionGuard Specification Under Development This version is unreleased. Star the repository and follow along for updates.","title":"v1.0.0"},{"location":"spec/1.0.0/1_Overview/#electionguard-specification","text":"Under Development This version is unreleased. Star the repository and follow along for updates.","title":"ElectionGuard Specification"},{"location":"use_cases/Audit/","text":"Audit Work in Progress This is a work in progress. Feel free to contribute.","title":"Audit"},{"location":"use_cases/Audit/#audit","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Audit"},{"location":"use_cases/Electronic_Delivery/","text":"Electronic Delivery Work in Progress This is a work in progress. Feel free to contribute.","title":"Electronic Delivery"},{"location":"use_cases/Electronic_Delivery/#electronic-delivery","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Electronic Delivery"},{"location":"use_cases/Mail_In/","text":"Mail In Work in Progress This is a work in progress. Feel free to contribute.","title":"Mail In"},{"location":"use_cases/Mail_In/#mail-in","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Mail In"},{"location":"use_cases/Precinct_Scan/","text":"Precinct Scan Work in Progress This is a work in progress. Feel free to contribute. Overview By design, the ElectionGuard SDK can be used to enable end-to-end verifiability (e2e-v) in a variety of use cases. This article discusses the \"default\" use case of ElectionGuard: an end-to-end verifiable election that uses precinct scanners where ballots are inserted (and approved) by voters directly 1 . This document aims to provide a \" vertical slice \" of the considerations and practices necessary to add end-to-end verifiability to an existing precinct scanner. We necessarily make assumptions about the compute and storage capabilities of the scanner itself, and the modifications necessary to implement end-to-end verifiability . In so doing, it illustrates the interlocking system of security and encryption that comprises an e2e-v system . Info ElectionGuard relies on slight adaptations of existing voting processes to accommodate different aspects of end-to-end verifiability . For example, many voting jurisdictions already have a procedure called ballot spoiling to handle mistakes voters make when they fill out ballots. A voter may inadvertently fill out a contest incorrectly by selecting more candidates than allowed. When the voter then proceeds to scan the ballot, the scanner stops the ballot and alerts the voter of the overvote ; the voter then has the opportunity, as allowed within the voting regulations and practices of the voting district, to start over with a new ballot; the ballot with the mistake is then spoiled and stored separately to ensure it is not included in the tabulation. ElectionGuard uses this spoil process to enable a voter to test the integrity of the system capturing their vote. Effectively, the voter acts as if they are going to vote, submitting their ballot into the scanner and enabling it to process and interpret the ballot. After the encryption of the ballot has occurred, and the verification code has been generated, the voter can decide NOT to cast this ballot via some kind of option on the summary screen presented by the scanner. End-to-end verifiability mandates that these challenged ballots , unlike cast ballots , be published separately from the tally, and in addition that they be decrypted and published in their decrypted state. When voters use their verification code to look up the provenance of these challenged ballots after the election record have been published, they will be able to see both that the ballot they challenged was NOT included in the tally, and also what its contents would have been if it were. When the contents of a challenged ballot are revealed to the voter and the selections match, their confidence about the provenance of their cast ballot is ideally bolstered. If the contents do not match their expectation, they should be given the means to flag this situation to election administrators to investigate. Thus, challenge ballots serve the dual role of affording voters the opportunity to more meaningfully evaluate the disposition of their voting preferences while also providing a security check on the voting system itself. Because the system has to be prepared for ANY voter to challenge a ballot, and because that challenge occurs AFTER the ElectionGuard encryption has occurred, the scanner has already committed its choice to ElectionGuard. And since the scanner can only encrypt ballots (only the tally process overseen by a quorum of election guardians has the \"power\" to decrypt anything ), the system is forced to act in good faith (if a small and random minority of voters can be relied upon to exercise challenges). This document illustrates these e2e-v concepts in the context of setting up and running an election. It begins with a general discussion of the precinct scan user experience and technical assumptions of scanner capabilities, and then runs an election, outlining where ElectionGuard needs to be integrated and ideally providing any wider security and integrity context for any process alterations that may obtain relative to current general election practice. Current Precinct Scan Voter Experience A typical voter flow for a precinct scan system is illustrated below. After a voter has acquired their ballot, they fill it out by hand or using a ballot marking device. When they finish they proceed to the scanner and insert the completed ballot. The scanner scans and interprets the ballot and generates a cast vote record , an electronic representation of the voter's selections. If all contests in a ballot are filled out properly and interpreted as such by the scanner, the ballot is accepted and the voter is free to leave the voting booth. If the scanner interprets the voter has voted for more options than the ballot contests allow (called an overvote ), the scanner stops the ballot from being deposited into the ballot box and prompts the voter whether they would like to have the ballot returned to fix the discrepancy. If the voter agrees, a poll worker is alerted and the ballot remediated by whatever process obtains, which could involve issuance of a new ballot and \"spoiling\" of the overvoted ballot. The scanner can also determine whether the voter didn't fill out all the contests available (called an undervote ). The scanner can be programmed to follow the same process as an overvote (returning the ballot for remediation), but election administrators often assume the undervote is intentional by the voter. Adapting Precinct Scan for End-to-end Verifiability (E2E-V) Voter Experience As outlined in the Verifiable Election page of the ElectionGuard SDK 2 , for end-to-end verifiability to apply, the precinct scanner itself must provide the following capabilities for each voter: immediately upon scanning the ballot, create an encrypted version of the ballot using the public key generated by the election guardians (see Key Ceremony) present the verification code generated by the encryption to the voter (ideally in paper format) present the means for the voter to cast or challenge (spoil) the ballot Technical Requirements For end-to-end verifiability, the scanner has to implement the user experience described above as well as generate and finalize an encrypted ballot reflecting the voter's selections. ElectionGuard assumes all other e2e-v functions such as key and tally ceremonies are performed independently of the scanner on modern laptop or desktop computers or secure cloud environments. Technical Implementation Overview and Operational Assumptions Precinct scanners, unlike other components of voting systems, are assumed to follow the economics and performance characteristics of embedded devices rather than consumer off-the-shelf (COTS) devices such as laptops. ElectionGuard assumes these devices operate in storage-limited environments more akin to operating systems such as Raspberry Pi than Windows 10. Information transfer (if not base storage) is assumed to occur via USB drives with capacities designed for space-efficient data constructs, not 4096-bit encryptions. To support operation in these environments, ElectionGuard enables an encryption-only library built in C++ from which it can target different standalone package deployments that generate encrypted ballots using a separately-provided public election key. Because encrypted ballots in modern elections can each occupy up to 1MB or more of device storage, ElectionGuard also specifies a dehydration \"process\" that allows a more space-efficient format for local storage and transmission post-election. Prior to initiating the tally and publishing process, these ballots are transferred to an external system and reconsitituted (and validated) by re-executing the encryption process using the dehydrated data as inputs. (See the discussions around ballot construction, chaining, etc., below to understand how dehydration should not affect system integrity or end-to-end verifiability.) General Election Setup Elections can be considered to have three core \"states\": the election itself, where voters cast their ballots, but also election setup and post-election data collection and tally publishing. ElectionGuard necessarily manifests in each state. Election setup generally consists of preparing the voting machines for the current election contests, running any pre-production testing, and final configuration for election readiness. For ElectionGuard, the public election key generated by the election guardians is deployed to the scanner at this time and, if necessary, the ElectionGuard executable (the scanner is assumed to be entirely offline and code and election-related data is transferred via USB storage devices). Poll workers should also be prompted to manually enter an election launch code (see below) generated uniquely for the current election at election instantiation. In modern US elections, voters often vote multiple contests, determined by the type of election they're voting in and where they live. Because of the diversity of contests that different voters are eligible to vote in [even within a single county or precinct (imagine school districts, utility districts, city councillors, etc.)], a single precinct scanner may need to recognize and interpret tens or even hundreds of different ballot styles in a single election. Ballot manifest Consider a ballot manifest the master list of all the contests voters could face in a single election. ElectionGuard assumes and validates the ballot manifest for a variety of criteria . ElectionGuard uses manifests to properly interpret ballots generally, but for records created by precinct scanners the manifest provides the means to reconstitute the encrypted ballots from the dehydrated records created. Strictly speaking, the ballot manifest isn't necessary for ElectionGuard until the tally process evaluates the encrypted ballots generated during the election, but the precinct scanner needs to encode ballots and votes properly for their downstream construction, and that is dependent on the unique ballot styles presented to voters, which themselves need to follow proper convention as well. Public encryption key One of the core innovations of ElectionGuard is the use of multiple election guardians to administer the creation of the election record. Guardians are intended to be independent, trustworthy individuals. They don't need to have technical skills, but they do need to physically perform tasks collectively with the other guardians at the beginning and end of elections. As part of the election setup process, or any time prior, the guardians meet to create the public key that will be used by the precinct scanner to encrypt voter ballots. The Logic and Accuracy Testing Scanner Final Production Setup Launch Code Scanner Election Operation Ballot Encryption Generation of Verification Code Ballot Chaining Ballot Dehydration Dehydrated ballot structure A dehydrated ballot must provide the following data to be properly rehydrated and preserve end-to-end verifiability. Label Type Description Notes ballot_object_id string Unique ID to identify each ballot in an election session_id string Unique ID to enable the correct sorting of the election ballot chain when rehydrated needs to be resilient across device restarts and other service interruptions launch_code integer 10-digit ID generated at election initiation by rolling of 10-sided dice used to protect against attacks to insert votes outside of election context. See insert reference here ballot_style_id string Uniquely identifies the set of contests and responses a voter encounters with their ballot Used as part of the rehydration and tally processes to ensure the ballot is correctly interpreted and reconstituted ballot_finalization_indicator flag Indicates whether ballot is CAST or CHALLENGED applied by scanner based on determination by voter ballot_selections array Set of responses (and, as applicable, non-responses) of voter to ballot style reflective of non-selections; critical for rehydration and re-establishment of ballot encryption artifacts ballot_extra_data array Additional data applied at contest level to capture non-selection data Principally envisioned for capturing ballot selection metadata for write-ins; each entry needs to identify contest and selection as well as extra data string ballot_nonce ? The nonce used as input to the encryption of the ballot selections See spec on Ballot Encryption previous_tracker_hash ? As discussed in ballot chaining the previous_tracker_hash is an input to the current ballot encryption See spec on Ballot Encryption verification_code_hash ? Hashed version of verification code generated by ballot encryption process Ballot Finalization Cast ballots Challenge ballots As distinct from scanners used solely for central tabulation, which occurs with mail-in voting or any tabulation / aggregation scenario where voters are not present when the cast vote record is created \u21a9 ElectionGuard Verifiable Election [https://www.electionguard.vote/guide/Verifiable_Election/] \u21a9","title":"Precinct Scan"},{"location":"use_cases/Precinct_Scan/#precinct-scan","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Precinct Scan"},{"location":"use_cases/Precinct_Scan/#overview","text":"By design, the ElectionGuard SDK can be used to enable end-to-end verifiability (e2e-v) in a variety of use cases. This article discusses the \"default\" use case of ElectionGuard: an end-to-end verifiable election that uses precinct scanners where ballots are inserted (and approved) by voters directly 1 . This document aims to provide a \" vertical slice \" of the considerations and practices necessary to add end-to-end verifiability to an existing precinct scanner. We necessarily make assumptions about the compute and storage capabilities of the scanner itself, and the modifications necessary to implement end-to-end verifiability . In so doing, it illustrates the interlocking system of security and encryption that comprises an e2e-v system . Info ElectionGuard relies on slight adaptations of existing voting processes to accommodate different aspects of end-to-end verifiability . For example, many voting jurisdictions already have a procedure called ballot spoiling to handle mistakes voters make when they fill out ballots. A voter may inadvertently fill out a contest incorrectly by selecting more candidates than allowed. When the voter then proceeds to scan the ballot, the scanner stops the ballot and alerts the voter of the overvote ; the voter then has the opportunity, as allowed within the voting regulations and practices of the voting district, to start over with a new ballot; the ballot with the mistake is then spoiled and stored separately to ensure it is not included in the tabulation. ElectionGuard uses this spoil process to enable a voter to test the integrity of the system capturing their vote. Effectively, the voter acts as if they are going to vote, submitting their ballot into the scanner and enabling it to process and interpret the ballot. After the encryption of the ballot has occurred, and the verification code has been generated, the voter can decide NOT to cast this ballot via some kind of option on the summary screen presented by the scanner. End-to-end verifiability mandates that these challenged ballots , unlike cast ballots , be published separately from the tally, and in addition that they be decrypted and published in their decrypted state. When voters use their verification code to look up the provenance of these challenged ballots after the election record have been published, they will be able to see both that the ballot they challenged was NOT included in the tally, and also what its contents would have been if it were. When the contents of a challenged ballot are revealed to the voter and the selections match, their confidence about the provenance of their cast ballot is ideally bolstered. If the contents do not match their expectation, they should be given the means to flag this situation to election administrators to investigate. Thus, challenge ballots serve the dual role of affording voters the opportunity to more meaningfully evaluate the disposition of their voting preferences while also providing a security check on the voting system itself. Because the system has to be prepared for ANY voter to challenge a ballot, and because that challenge occurs AFTER the ElectionGuard encryption has occurred, the scanner has already committed its choice to ElectionGuard. And since the scanner can only encrypt ballots (only the tally process overseen by a quorum of election guardians has the \"power\" to decrypt anything ), the system is forced to act in good faith (if a small and random minority of voters can be relied upon to exercise challenges). This document illustrates these e2e-v concepts in the context of setting up and running an election. It begins with a general discussion of the precinct scan user experience and technical assumptions of scanner capabilities, and then runs an election, outlining where ElectionGuard needs to be integrated and ideally providing any wider security and integrity context for any process alterations that may obtain relative to current general election practice.","title":"Overview"},{"location":"use_cases/Precinct_Scan/#current-precinct-scan-voter-experience","text":"A typical voter flow for a precinct scan system is illustrated below. After a voter has acquired their ballot, they fill it out by hand or using a ballot marking device. When they finish they proceed to the scanner and insert the completed ballot. The scanner scans and interprets the ballot and generates a cast vote record , an electronic representation of the voter's selections. If all contests in a ballot are filled out properly and interpreted as such by the scanner, the ballot is accepted and the voter is free to leave the voting booth. If the scanner interprets the voter has voted for more options than the ballot contests allow (called an overvote ), the scanner stops the ballot from being deposited into the ballot box and prompts the voter whether they would like to have the ballot returned to fix the discrepancy. If the voter agrees, a poll worker is alerted and the ballot remediated by whatever process obtains, which could involve issuance of a new ballot and \"spoiling\" of the overvoted ballot. The scanner can also determine whether the voter didn't fill out all the contests available (called an undervote ). The scanner can be programmed to follow the same process as an overvote (returning the ballot for remediation), but election administrators often assume the undervote is intentional by the voter.","title":"Current Precinct Scan Voter Experience"},{"location":"use_cases/Precinct_Scan/#adapting-precinct-scan-for-end-to-end-verifiability-e2e-v","text":"","title":"Adapting Precinct Scan for End-to-end Verifiability (E2E-V)"},{"location":"use_cases/Precinct_Scan/#voter-experience","text":"As outlined in the Verifiable Election page of the ElectionGuard SDK 2 , for end-to-end verifiability to apply, the precinct scanner itself must provide the following capabilities for each voter: immediately upon scanning the ballot, create an encrypted version of the ballot using the public key generated by the election guardians (see Key Ceremony) present the verification code generated by the encryption to the voter (ideally in paper format) present the means for the voter to cast or challenge (spoil) the ballot","title":"Voter Experience"},{"location":"use_cases/Precinct_Scan/#technical-requirements","text":"For end-to-end verifiability, the scanner has to implement the user experience described above as well as generate and finalize an encrypted ballot reflecting the voter's selections. ElectionGuard assumes all other e2e-v functions such as key and tally ceremonies are performed independently of the scanner on modern laptop or desktop computers or secure cloud environments.","title":"Technical Requirements"},{"location":"use_cases/Precinct_Scan/#technical-implementation","text":"","title":"Technical Implementation"},{"location":"use_cases/Precinct_Scan/#overview-and-operational-assumptions","text":"Precinct scanners, unlike other components of voting systems, are assumed to follow the economics and performance characteristics of embedded devices rather than consumer off-the-shelf (COTS) devices such as laptops. ElectionGuard assumes these devices operate in storage-limited environments more akin to operating systems such as Raspberry Pi than Windows 10. Information transfer (if not base storage) is assumed to occur via USB drives with capacities designed for space-efficient data constructs, not 4096-bit encryptions. To support operation in these environments, ElectionGuard enables an encryption-only library built in C++ from which it can target different standalone package deployments that generate encrypted ballots using a separately-provided public election key. Because encrypted ballots in modern elections can each occupy up to 1MB or more of device storage, ElectionGuard also specifies a dehydration \"process\" that allows a more space-efficient format for local storage and transmission post-election. Prior to initiating the tally and publishing process, these ballots are transferred to an external system and reconsitituted (and validated) by re-executing the encryption process using the dehydrated data as inputs. (See the discussions around ballot construction, chaining, etc., below to understand how dehydration should not affect system integrity or end-to-end verifiability.)","title":"Overview and Operational Assumptions"},{"location":"use_cases/Precinct_Scan/#general-election-setup","text":"Elections can be considered to have three core \"states\": the election itself, where voters cast their ballots, but also election setup and post-election data collection and tally publishing. ElectionGuard necessarily manifests in each state. Election setup generally consists of preparing the voting machines for the current election contests, running any pre-production testing, and final configuration for election readiness. For ElectionGuard, the public election key generated by the election guardians is deployed to the scanner at this time and, if necessary, the ElectionGuard executable (the scanner is assumed to be entirely offline and code and election-related data is transferred via USB storage devices). Poll workers should also be prompted to manually enter an election launch code (see below) generated uniquely for the current election at election instantiation. In modern US elections, voters often vote multiple contests, determined by the type of election they're voting in and where they live. Because of the diversity of contests that different voters are eligible to vote in [even within a single county or precinct (imagine school districts, utility districts, city councillors, etc.)], a single precinct scanner may need to recognize and interpret tens or even hundreds of different ballot styles in a single election.","title":"General Election Setup"},{"location":"use_cases/Precinct_Scan/#ballot-manifest","text":"Consider a ballot manifest the master list of all the contests voters could face in a single election. ElectionGuard assumes and validates the ballot manifest for a variety of criteria . ElectionGuard uses manifests to properly interpret ballots generally, but for records created by precinct scanners the manifest provides the means to reconstitute the encrypted ballots from the dehydrated records created. Strictly speaking, the ballot manifest isn't necessary for ElectionGuard until the tally process evaluates the encrypted ballots generated during the election, but the precinct scanner needs to encode ballots and votes properly for their downstream construction, and that is dependent on the unique ballot styles presented to voters, which themselves need to follow proper convention as well.","title":"Ballot manifest"},{"location":"use_cases/Precinct_Scan/#public-encryption-key","text":"One of the core innovations of ElectionGuard is the use of multiple election guardians to administer the creation of the election record. Guardians are intended to be independent, trustworthy individuals. They don't need to have technical skills, but they do need to physically perform tasks collectively with the other guardians at the beginning and end of elections. As part of the election setup process, or any time prior, the guardians meet to create the public key that will be used by the precinct scanner to encrypt voter ballots. The","title":"Public encryption key"},{"location":"use_cases/Precinct_Scan/#logic-and-accuracy-testing","text":"","title":"Logic and Accuracy Testing"},{"location":"use_cases/Precinct_Scan/#scanner-final-production-setup","text":"","title":"Scanner Final Production Setup"},{"location":"use_cases/Precinct_Scan/#launch-code","text":"","title":"Launch Code"},{"location":"use_cases/Precinct_Scan/#scanner-election-operation","text":"","title":"Scanner Election Operation"},{"location":"use_cases/Precinct_Scan/#ballot-encryption","text":"","title":"Ballot Encryption"},{"location":"use_cases/Precinct_Scan/#generation-of-verification-code","text":"","title":"Generation of Verification Code"},{"location":"use_cases/Precinct_Scan/#ballot-chaining","text":"","title":"Ballot Chaining"},{"location":"use_cases/Precinct_Scan/#ballot-dehydration","text":"","title":"Ballot Dehydration"},{"location":"use_cases/Precinct_Scan/#dehydrated-ballot-structure","text":"A dehydrated ballot must provide the following data to be properly rehydrated and preserve end-to-end verifiability. Label Type Description Notes ballot_object_id string Unique ID to identify each ballot in an election session_id string Unique ID to enable the correct sorting of the election ballot chain when rehydrated needs to be resilient across device restarts and other service interruptions launch_code integer 10-digit ID generated at election initiation by rolling of 10-sided dice used to protect against attacks to insert votes outside of election context. See insert reference here ballot_style_id string Uniquely identifies the set of contests and responses a voter encounters with their ballot Used as part of the rehydration and tally processes to ensure the ballot is correctly interpreted and reconstituted ballot_finalization_indicator flag Indicates whether ballot is CAST or CHALLENGED applied by scanner based on determination by voter ballot_selections array Set of responses (and, as applicable, non-responses) of voter to ballot style reflective of non-selections; critical for rehydration and re-establishment of ballot encryption artifacts ballot_extra_data array Additional data applied at contest level to capture non-selection data Principally envisioned for capturing ballot selection metadata for write-ins; each entry needs to identify contest and selection as well as extra data string ballot_nonce ? The nonce used as input to the encryption of the ballot selections See spec on Ballot Encryption previous_tracker_hash ? As discussed in ballot chaining the previous_tracker_hash is an input to the current ballot encryption See spec on Ballot Encryption verification_code_hash ? Hashed version of verification code generated by ballot encryption process","title":"Dehydrated ballot structure"},{"location":"use_cases/Precinct_Scan/#ballot-finalization","text":"","title":"Ballot Finalization"},{"location":"use_cases/Precinct_Scan/#cast-ballots","text":"","title":"Cast ballots"},{"location":"use_cases/Precinct_Scan/#challenge-ballots","text":"As distinct from scanners used solely for central tabulation, which occurs with mail-in voting or any tabulation / aggregation scenario where voters are not present when the cast vote record is created \u21a9 ElectionGuard Verifiable Election [https://www.electionguard.vote/guide/Verifiable_Election/] \u21a9","title":"Challenge ballots"},{"location":"use_cases/Rescans_and_Recounts/","text":"Rescans and Recounts Warning This is a documented but not currently implemented capability. See the Roadmap for implementation details and status. Overview In the course of an election with paper ballots, occasions may arise when all or some of the ballots in an election may need to be rescanned without being in the presence of the voter. For example, if a precinct scanner fails on election day, some municipalities may require a new scanner to be activated and the ballots scanned through the failed scanner to be re-scanned in the new scanner; those rescans would likely not be conducted in the presence of the affected voters, and the verification codes generated from the subsequent scans would not be available to them. Similarly, some elections require multiple recounts, including hand tallies, to resolve challenges or recounts triggered by narrow margins of victory. Ballots may be included or excluded from subsequent recounts dependent on the interpretation of the scans or their inclusion or exclusion in the the subsequent tallies. Info Depending on how the ballot is encrypted (such as whether ballot-chaining is being used), the verification codes generated in the rescan would not be the same. The \"default\" implementation of ElectionGuard, which uses the unique ID of the device performing the encryption as part of the encryption itself, would generate a different verification code if the same ballot is scanned on a different device. If ballot-chaining or any time-based component were included in the encryption, even subsequent scans of the same ballot on the same scanner would generate a different verification code. When a voter checks whether their ballot was included in the ElectionGuard published artifacts, the information should reflect whether the ballot was included (and even more importantly not included) in any subsequent tallies published by the election administration. This must be accomplished without undermining the core integrity and privacy concerns of the verification processes. Warning The proposed process mandates a unique ballot identifier be generated by the host voting system (not ElectionGuard), printed on the ballot, and captured as part of the ElectionGuard metadata. Proposed Approach To maintain the security and integrity of the original election record, rescans and recounts are guardian-based processes. This requirement presents potentially significant additional compute both for the local guardian device / hardware security module and any cloud-based approach to scale the cross-tally mapping. Encrypting a Unique Ballot ID Since a rescan or recount can occur on any independent device, the information for mapping must be present on and derived from the paper ballot itself. Specifically, in addition to all the contests and candidates, there must be an ID unique to the election printed on the ballot. When scanned by the scanner, that ID is included in the encrypted ballot metadata encrypted by the auxiliary guardian RSA key separate from the El Gamal encryption 1 used for the ballot contents. Alert Municipalities that do not allow the printing of unique identifiers on their paper ballots cannot use ElectionGuard for the rescan scenario, since there is no way to perform any mapping across independent tallies Diffing an Election Invoking a Rescan or Recount After the base ElectionGuard verifiable tally has been generated (and, optionally, published) a rescan or recount can be performed. Optimizing the Compute Because the primary joint public key is an ElGamal key, it is optimized for the ones and zeroes that constitute the contents of a ballot, not the generic string values necessary to support arbitrary IDs. \u21a9","title":"Rescans and Recounts"},{"location":"use_cases/Rescans_and_Recounts/#rescans-and-recounts","text":"Warning This is a documented but not currently implemented capability. See the Roadmap for implementation details and status.","title":"Rescans and Recounts"},{"location":"use_cases/Rescans_and_Recounts/#overview","text":"In the course of an election with paper ballots, occasions may arise when all or some of the ballots in an election may need to be rescanned without being in the presence of the voter. For example, if a precinct scanner fails on election day, some municipalities may require a new scanner to be activated and the ballots scanned through the failed scanner to be re-scanned in the new scanner; those rescans would likely not be conducted in the presence of the affected voters, and the verification codes generated from the subsequent scans would not be available to them. Similarly, some elections require multiple recounts, including hand tallies, to resolve challenges or recounts triggered by narrow margins of victory. Ballots may be included or excluded from subsequent recounts dependent on the interpretation of the scans or their inclusion or exclusion in the the subsequent tallies. Info Depending on how the ballot is encrypted (such as whether ballot-chaining is being used), the verification codes generated in the rescan would not be the same. The \"default\" implementation of ElectionGuard, which uses the unique ID of the device performing the encryption as part of the encryption itself, would generate a different verification code if the same ballot is scanned on a different device. If ballot-chaining or any time-based component were included in the encryption, even subsequent scans of the same ballot on the same scanner would generate a different verification code. When a voter checks whether their ballot was included in the ElectionGuard published artifacts, the information should reflect whether the ballot was included (and even more importantly not included) in any subsequent tallies published by the election administration. This must be accomplished without undermining the core integrity and privacy concerns of the verification processes. Warning The proposed process mandates a unique ballot identifier be generated by the host voting system (not ElectionGuard), printed on the ballot, and captured as part of the ElectionGuard metadata.","title":"Overview"},{"location":"use_cases/Rescans_and_Recounts/#proposed-approach","text":"To maintain the security and integrity of the original election record, rescans and recounts are guardian-based processes. This requirement presents potentially significant additional compute both for the local guardian device / hardware security module and any cloud-based approach to scale the cross-tally mapping.","title":"Proposed Approach"},{"location":"use_cases/Rescans_and_Recounts/#encrypting-a-unique-ballot-id","text":"Since a rescan or recount can occur on any independent device, the information for mapping must be present on and derived from the paper ballot itself. Specifically, in addition to all the contests and candidates, there must be an ID unique to the election printed on the ballot. When scanned by the scanner, that ID is included in the encrypted ballot metadata encrypted by the auxiliary guardian RSA key separate from the El Gamal encryption 1 used for the ballot contents. Alert Municipalities that do not allow the printing of unique identifiers on their paper ballots cannot use ElectionGuard for the rescan scenario, since there is no way to perform any mapping across independent tallies","title":"Encrypting a Unique Ballot ID"},{"location":"use_cases/Rescans_and_Recounts/#diffing-an-election","text":"","title":"Diffing an Election"},{"location":"use_cases/Rescans_and_Recounts/#invoking-a-rescan-or-recount","text":"After the base ElectionGuard verifiable tally has been generated (and, optionally, published) a rescan or recount can be performed.","title":"Invoking a Rescan or Recount"},{"location":"use_cases/Rescans_and_Recounts/#optimizing-the-compute","text":"Because the primary joint public key is an ElGamal key, it is optimized for the ones and zeroes that constitute the contents of a ballot, not the generic string values necessary to support arbitrary IDs. \u21a9","title":"Optimizing the Compute"}]}